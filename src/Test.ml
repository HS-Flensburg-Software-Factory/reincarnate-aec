open Logging
open Util
open Timeout
open NumSys
open MPFRNumSys
open LinAlg
open Geom
open Mesh
open CAD
open LambdaCAD
open Synth
open SynthBench
open RPriorityQueue

let () =
  Logging.set_log (open_out "reincarnate-unit-tests.log")

module N = NumSys.FloatNum
(* Two tests fail with FloatNum but actually work with MPFR_128 *)
(*
module N = MPFRNum_128
module N = NumSys.ExHackedNum
*)

let _ =
  N.set_eps_abs (N.of_string "1e-10");
  N.set_eps_rel (N.of_string "1e-10")

(*
TODO: Several of the tests in this file use large float constants.
We hope to convert them to exact real values using the [| e |] syntax
at some point in the future. Here are some possible constant values.

In `Geom3.part_tri.test011` and `Geom3.part_tri.test012`

    0.43827
    0.46631 -- [| tan(5*PI/36) |]
    0.78021

In `Mesh.face_mem.test003`

    0.14054 -- [| tan(2*PI/45) |]
    0.49858 -- [| tan(PI/180*26.5) |]
    0.67601 -- [| 3/7 + cos(PI/6) * 2 / 7 |]
    0.71406 -- ?? - (cos(PI/5) - cos(PI/10)) /
      (10*cos(3*PI/10) + 6*cos(2*PI/5))
    0.60182 -- [| sin(37*PI/180) |]
    0.79864 -- [| cos(37*PI/180) |]
*)

let num_of_string x =
  if x.[0] = '['
  then N.of_const (RParse.rconst_of_string x)
  else N.of_string x

module Mat = LinAlg.Matrix(N)

module Q = PriorityQueue(N)

module G1 = Geom1(N)
module M1 = RawMesh1(N)(G1)
module C1 = RawCAD1(N)(M1)

module G2 = Geom2(N)
module M2 = RawMesh2(N)(G2)
module C2 = RawCAD2(N)(M2)

module G3 = RawGeom3(N)(Mat)
module M3 = RawMesh3(N)(G3)
module C3 = RawCAD3(N)(M3)

module LC = RawLC(N)(C1)(C2)(C3)

module SB1 = SynthBench1(M1)(C1)
module SB2 = SynthBench2(M2)(C2)
module SB3 = SynthBench3(M3)(C3)

module S1 = RawSynth1(N)(Q)(G1)(M1)(C1)(SB1)
module S2 = RawSynth2(N)(Q)(G2)(M2)(C2)(SB2)
module S3 = RawSynth3(N)(Q)(G3)(M3)(C3)(SB3)

module M1Parse  = RParse.MakeMesh1Parser(N)(M1)
module M2Parse  = RParse.MakeMesh2Parser(N)(M2)
module M3Parse  = RParse.MakeMesh3Parser(N)(M3)
module STLParse = RParse.MakeSTLParser(N)(M3)
module C1Parse  = RParse.MakeCAD1Parser(N)(M1)(C1)
module C2Parse  = RParse.MakeCAD2Parser(N)(M2)(C2)
module C3Parse  = RParse.MakeCAD3Parser(N)(M3)(C3)
module LCParser = RParse.MakeLCParser(N)(LC)

(** {2 Testing} *)

let _timeout =
  ref 0

let _pass =
  if Unix.isatty Unix.stdout
  then "\027[1;32mPASS\027[0m"
  else "PASS"

let _fail =
  if Unix.isatty Unix.stdout
  then "\027[1;31mFAIL\027[0m"
  else "FAIL"

let passed: string list ref = ref []
let failed: string list ref = ref []

let verbose = ref false

let cons_bang lr x =
  lr := x :: !lr

let print_outcome group test ?fail_msg ok =
  Printf.printf "  %-25s : " test;
  if ok then begin
    print_endline _pass;
    cons_bang passed (group ^ "." ^ test)
  end else begin
    print_endline _fail;
    begin match !verbose, fail_msg with
    | true, Some thunk -> print_string (thunk ())
    | _, _ -> ()
    end;
    cons_bang failed (group ^ "." ^ test)
  end

let check_outcome_equiv
  ?describe_input
  ?output_to_string
  group
  test
  equiv
  expected
  actual
=
  let aux () =
    let input =
      match describe_input with
      | None   -> ""
      | Some f -> Printf.sprintf "input: %s\n" (f ())
    in
    let output =
      match output_to_string with
      | None   -> ""
      | Some f ->
          Printf.sprintf "expected: %s\nactual: %s\n"
            (f expected)
            (f actual)
    in
    input ^ output
  in
  print_outcome
    group
    test
    ?fail_msg:(Some aux)
    (equiv expected actual)


let check_outcome_eq
  ?describe_input ?output_to_string
  group test expected actual =
    check_outcome_equiv ?describe_input
    ?output_to_string group test
    (=) expected actual

type test =
  | Test : string * (string * 'a -> unit) * (string * 'a) list -> test

let tests : test list ref = ref []

let register
  group
  (f : string -> string * 'a -> unit)
  (ts : (string * 'a) list)
=
  let f' (nm, x) =
    try
      Timeout.exn2 !_timeout
        f group (nm, x)
    with ParseCommon.Error msg ->
         Printf.printf "%s\n" msg;
         Printexc.print_backtrace stdout;
         check_outcome_equiv group nm (fun a r -> false) "" ""
       | e ->
         Printf.printf "%s\n" (Printexc.to_string e);
         Printexc.print_backtrace stdout;
         check_outcome_equiv group nm (fun a r -> false) "" ""
  in
  cons_bang tests (Test (group, f', ts))

let register' t_to_string group f ts =
  register group f (List.map (fun t -> (t_to_string t, t)) ts)

let register3 group f ts =
  let swizzle   (nm, a, b)   = (nm, (a, b)) in
  let unswizzle (nm, (a, b)) = (nm, a, b)   in
  let f' group x = x |> unswizzle |> f group in
  register group f' (List.map swizzle ts)

let register4 group f ts =
  let swizzle   (nm, a, b, c)   = (nm, (a, b, c)) in
  let unswizzle (nm, (a, b, c)) = (nm, a, b, c)   in
  let f' group x = x |> unswizzle |> f group in
  register group f' (List.map swizzle ts)

let register5 group f ts =
  let swizzle   (nm, a, b, c, d)   = (nm, (a, b, c, d)) in
  let unswizzle (nm, (a, b, c, d)) = (nm, a, b, c, d)   in
  let f' group x = x |> unswizzle |> f group in
  register group f' (List.map swizzle ts)

let register6 group f ts =
  let swizzle   (nm, a, b, c, d, e)   = (nm, (a, b, c, d, e)) in
  let unswizzle (nm, (a, b, c, d, e)) = (nm, a, b, c, d, e)   in
  let f' group x = x |> unswizzle |> f group in
  register group f' (List.map swizzle ts)

let run_test (pred : string -> bool) = function
  | Test (group, f, ts) ->
      let ts =
        List.filter (fun (s, _) -> pred (group ^ "." ^ s)) ts in
      match ts with
      | [] -> ()
      | _ -> begin
          Printf.printf "*** %s tests ***\n" group;
          List.iter f ts;
          print_endline ""
        end


(* test modules *)
module TestLinAlg = struct
  module Mat = LinAlg.Matrix(N)

  let test_det group (nm, m', expected) =
    let m = List.map (List.map N.of_string) m' in
    let d = Mat.det m in
    check_outcome_eq group nm (N.of_string expected) d

  let _ =
    register3 "LinAlg.det" test_det
      [ ( "test001"
        , [ ["1"; "0"; "0"]
          ; ["0"; "1"; "0"]
          ; ["0"; "0"; "1"]
          ]
        , "1"
        )
      ; ( "test002"
        , [ ["1"; "0"]
          ; ["0"; "1"]
          ]
        , "1"
        )
      ; ( "test003"
        , [ ["1"; "0"; "0"; "0"]
          ; ["0"; "1"; "0"; "0"]
          ; ["0"; "0"; "1"; "0"]
          ; ["0"; "0"; "0"; "1"]
          ]
        , "1"
        )
      ]
end

module TestUtil = struct

  (* Util between test *)

  let test_between group (nm, abc, expected) =
    let (a, b, c) =
      Util.triple_map num_of_string abc
    in
    let actual =
      Util.between N.cmp a b c
    in
    check_outcome_eq group nm expected actual

  let _ =
    register3 "Util.between" test_between
      [ ( "test001"
        , ("-1.5", "-1.5", "-1.5")
        , true
        )
      ; ( "test002"
        , ("0", "0.099", "1")
        , true
        )
      ; ( "test003"
        , ("5.0", "9.0", "7.0")
        , false
        )
      ]

  let test_range group (nm, ((lo, hi), expected)) =
    let actual =
      Util.range lo hi
    in
    check_outcome_eq group nm expected actual

  let _ =
    register'
      (fun ((lo, hi), _) ->
        Printf.sprintf "[%d,%d)" lo hi)
      "Util.range" test_range
      [ ( (0, 5)
        , [0; 1; 2; 3; 4] )
      ; ( (-3, -1)
        , [-3; -2] )
      ]

  let test_substring_at group (nm, (n, h, i, expected)) =
    let actual = Util.substring_at n h i in
    check_outcome_eq group nm expected actual

  let _ =
    register'
      (fun (n, h, i, _) ->
        Printf.sprintf "%s %s %d" n h i)
      "Util.substring_at" test_substring_at
      [ ( "foo"
        , "abcfoo123"
        , 0
        , false
        )
      ; ( "foo"
        , "abcfoo123"
        , 3
        , true
        )
      ]

  let test_is_substring group (nm, (n, h, expected)) =
    let actual = Util.is_substring n h in
    check_outcome_eq group nm expected actual

  let _ =
    register'
      (fun (n, h, _) ->
        Printf.sprintf "%s %s" n h)
      "Util.is_substring" test_is_substring
      [ ( "foo"
        , "abcfoo123"
        , true
        )
      ; ( "foo"
        , "abc123"
        , false
        )
      ]
end

module TestExactArith = struct

  let test_positive group (nm, x, expected) =
    let c = RParse.rconst_of_string x in
    let x = ExHackedNum.of_const c in
    let actual =
      match x with
      | ExactArith.ExHackedArith.Exact c -> ExactArith.Chebynomial.positive c
      | _ -> failwith "TestExactArith.test_positive: parse error"
    in
    let describe_input () = RealConst.raw_to_string c in
    let output_to_string = string_of_bool in
    check_outcome_eq
      ~describe_input
      ~output_to_string
      group nm expected actual

  let _ =
    register3 "ExactArith.positive" test_positive
      [ ( "test001"
        , "[| 19741555887132/22842409025  - 7510082870176/4568481805 * cos(PI/10) + 31941725551576/22842409025 * cos(PI/5) - 4641303311844/4568481805 * cos(3*PI/10) + 12200169664444/22842409025 * cos(2*PI/5) |]"
        , true
        )
      ]
end

module TestSynth2 = struct

  module S = S2
  module M = M2

  let test_canon group (nm, m', e) =
    let m = M2Parse.of_string m' in
    let (canon, t, d, s) = S.canonicalize m  in
    let expected = M2Parse.of_string e in
    check_outcome_equiv group nm M.equiv expected canon

  let _ =
    register3 "Synth2.canonicalize" test_canon
      [ ( "test001"
        , "[ ((0.0, 0.0), (1.0, 0.0))
           ; ((1.0, 0.0), (1.0, 1.0))
           ; ((1.0, 1.0), (0.0, 1.0))
           ; ((0.0, 1.0), (0.0, 0.0))
           ]"
       , "[ (([| -cos(PI/4) |], -0.0000000000), ( 0.0000000000, [| -cos(PI/4) |]))
          ; (( 0.0000000000, [| -cos(PI/4) |]), ( [| cos(PI/4) |],  0.0000000000))
          ; ((-0.0000000000,  [| cos(PI/4) |]), ( [| cos(PI/4) |],  0.0000000000))
          ; (([| -cos(PI/4) |], -0.0000000000), (-0.0000000000, [| cos(PI/4) |]))
          ]"
        )
      ; ( "test002"
        , "[ ((-0.00000, [| -cos(PI/4) |]), ( [| cos(PI/4) |], -0.00000))
           ; (( 0.00000,  [| cos(PI/4) |]), ( [| cos(PI/4) |], -0.00000))
           ; (([| -cos(PI/4) |],  0.00000), ( 0.00000,  [| cos(PI/4) |]))
           ; (([| -cos(PI/4) |],  0.00000), (-0.00000, [| -cos(PI/4) |]))
           ]"
        , "[ (( 0.0, -0.5), (0.5,  0.0))
           ; (( 0.0,  0.5), (0.5,  0.0))
           ; ((-0.5,  0.0), (0.0,  0.5))
           ; ((-0.5,  0.0), (0.0, -0.5))
           ]"
        )
      ]

end

module TestSynth3 = struct

  module S = S3
  module M = M3
  module C = C3

 (* for now, only sanity checking that canon doesn't crash *)
 let test_canon_nocrash group (nm, c, expected) =
   let m = C.compile c in
   let (cm, t, (rx, ry, rz), s) = S.canon m in
   let ts = [t; s] in
   let actual = List.length ts = 2 in
   check_outcome_eq group nm expected actual

  let _ =
    register3 "Synth3.canon" test_canon_nocrash
      [ ( "test001"
        , C.Unit
        , true
        )
      ; ( "test002"
        , C.Cylinder
        , true
        )
      ; ( "test003"
        , C.Hexagon
        , true
        )
      ; ( "test004"
        , C.Pentagon
        , true
        )
      ]
end

module TestMesh3 = struct
  module G = G3
  module M = M3
  module M3Parse  = RParse.MakeMesh3Parser(N)(M)
  module STLParse = RParse.MakeSTLParser(N)(M)

  (* Mesh3 directed_isects tests *)
  let test_dir_isect group (nm, m', a', b', expected) =
    let m = M3Parse.of_string m' in
    let a = Util.triple_map num_of_string a' in
    let b = Util.triple_map num_of_string b' in
    let l = M.directed_isects' m a b in
    check_outcome_eq group nm expected (List.length l)

  let _ =
    register5 "Mesh3.dir_isect" test_dir_isect
      [ ( "test001"
        , "[]"
        , ("5", "0.5", "0.5")
        , ("1", "0.5", "0.5")
        , 0
        )
      ; ( "test002"
        , "[ ((0.0, 0.0, 0.0), (1.0, 0.0, 0.0), (1.0, 1.0, 0.0))
           ; ((0.0, 0.0, 0.0), (1.0, 1.0, 0.0), (0.0, 1.0, 0.0))
           ; ((0.0, 0.0, 1.0), (1.0, 0.0, 1.0), (1.0, 1.0, 1.0))
           ; ((0.0, 0.0, 1.0), (1.0, 1.0, 1.0), (0.0, 1.0, 1.0))
           ; ((0.0, 0.0, 0.0), (1.0, 0.0, 0.0), (1.0, 0.0, 1.0))
           ; ((0.0, 0.0, 0.0), (1.0, 0.0, 1.0), (0.0, 0.0, 1.0))
           ; ((0.0, 1.0, 0.0), (1.0, 1.0, 0.0), (1.0, 1.0, 1.0))
           ; ((0.0, 1.0, 0.0), (1.0, 1.0, 1.0), (0.0, 1.0, 1.0))
           ; ((0.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 1.0, 1.0))
           ; ((0.0, 0.0, 0.0), (0.0, 1.0, 1.0), (0.0, 0.0, 1.0))
           ; ((1.0, 0.0, 0.0), (1.0, 1.0, 0.0), (1.0, 1.0, 1.0))
           ; ((1.0, 0.0, 0.0), (1.0, 1.0, 1.0), (1.0, 0.0, 1.0))
           ]"
        , ("5", "0.3", "0.5")
        , ("0", "0.3", "0.5")
        , 2
        )
      ; ( "test003"
        , "[ ((-0.0000000000, -0.0000000000, -0.0000000000), ([| cos(PI/4) |], -0.0000000000, [| -cos(PI/4) |]), ([| cos(PI/4) |], 1.0000000000, [| -cos(PI/4) |]))
           ; ((0.0000000000, 0.0000000000, 0.0000000000), (0.0000000000, 1.0000000000, 0.0000000000), ([| cos(PI/4) |], 1.0000000000, [| -cos(PI/4) |]))
           ; ((1.0000000000, 0.0000000000, [| 2*cos(PI/4) - 1 |]), ([| 2*cos(PI/4) |], 0.0000000000, 0.0000000000), ([| 2*cos(PI/4) |], 1.0000000000, 0.0000000000))
           ; ((1.0000000000, 0.0000000000, [| 2*cos(PI/4) - 1 |]), (1.0000000000, [| 2*cos(PI/4) - 1 |], [| 2*cos(PI/4) - 1 |]), ([| 2*cos(PI/4) |], 1.0000000000, 0.0000000000))
           ; (([| cos(PI/4) |], 0.0000000000, [| cos(PI/4) |]), (1.0000000000, 0.0000000000, [| 2*cos(PI/4) - 1 |]), (1.0000000000, [| 2*cos(PI/4) - 1 |], [| 2*cos(PI/4) - 1 |]))
           ; (([| cos(PI/4) |], 0.0000000000, [| cos(PI/4) |]), ([| cos(PI/4) |], 1.0000000000, [| cos(PI/4) |]), (1.0000000000, 1.0000000000, [| 2*cos(PI/4) - 1 |]))
           ; ((1.0000000000, [| 2*cos(PI/4) - 1 |], [| 2*cos(PI/4) - 1 |]), (1.0000000000, 1.0000000000, [| 2*cos(PI/4) - 1 |]), ([| 2*cos(PI/4) |], 1.0000000000, 0.0000000000))
           ; (([| cos(PI/4) |], 0.0000000000, [| cos(PI/4) |]), (1.0000000000, [| 2*cos(PI/4) - 1 |], [| 2*cos(PI/4) - 1 |]), (1.0000000000, 1.0000000000, [| 2*cos(PI/4) - 1 |]))
           ; ((0.0000000000, 0.0000000000, 0.0000000000), ([| cos(PI/4) |], 0.0000000000, [| -cos(PI/4) |]), (1.0000000000, 0.0000000000, 0.0000000000))
           ; (([| cos(PI/4) |], 0.0000000000, [| -cos(PI/4) |]), (1.0000000000, 0.0000000000, 0.0000000000), ([| 2*cos(PI/4) |], 0.0000000000, 0.0000000000))
           ; ((0.0000000000, 0.0000000000, 0.0000000000), ([| cos(PI/4) |], 0.0000000000, [| cos(PI/4) |]), (1.0000000000, 0.0000000000, 0.0000000000))
           ; (([| cos(PI/4) |], 0.0000000000, [| cos(PI/4) |]), (1.0000000000, 0.0000000000, 0.0000000000), (1.0000000000, 0.0000000000, [| 2*cos(PI/4) - 1 |]))
           ; ((1.0000000000, 0.0000000000, 0.0000000000), (1.0000000000, 0.0000000000, [| 2*cos(PI/4) - 1 |]), ([| 2*cos(PI/4) |], 0.0000000000, 0.0000000000))
           ; ((0.0000000000, 1.0000000000, 0.0000000000), ([| cos(PI/4) |], 1.0000000000, [| -cos(PI/4) |]), (1.0000000000, 1.0000000000, 0.0000000000))
           ; (([| cos(PI/4) |], 1.0000000000, [| -cos(PI/4) |]), (1.0000000000, 1.0000000000, 0.0000000000), ([| 2*cos(PI/4) |], 1.0000000000, 0.0000000000))
           ; ((0.0000000000, 1.0000000000, 0.0000000000), ([| cos(PI/4) |], 1.0000000000, [| cos(PI/4) |]), (1.0000000000, 1.0000000000, 0.0000000000))
           ; (([| cos(PI/4) |], 1.0000000000, [| cos(PI/4) |]), (1.0000000000, 1.0000000000, 0.0000000000), (1.0000000000, 1.0000000000, [| 2*cos(PI/4) - 1 |]))
           ; ((1.0000000000, 1.0000000000, 0.0000000000), (1.0000000000, 1.0000000000, [| 2*cos(PI/4) - 1 |]), ([| 2*cos(PI/4) |], 1.0000000000, 0.0000000000))
           ; ((0.0000000000, 0.0000000000, 0.0000000000), (0.0000000000, 1.0000000000, 0.0000000000), ([| cos(PI/4) |], 1.0000000000, [| cos(PI/4) |]))
           ; ((0.0000000000, 0.0000000000, 0.0000000000), ([| cos(PI/4) |], 0.0000000000, [| cos(PI/4) |]), ([| cos(PI/4) |], 1.0000000000, [| cos(PI/4) |]))
           ; (([| cos(PI/4) |], 0.0000000000, [| -cos(PI/4) |]), ([| cos(PI/4) |], 1.0000000000, [| -cos(PI/4) |]), ([| 2*cos(PI/4) |], 1.0000000000, 0.0000000000))
           ; (([| cos(PI/4) |], 0.0000000000, [| -cos(PI/4) |]), ([| 2*cos(PI/4) |], 0.0000000000, 0.0000000000), ([| 2*cos(PI/4) |], 1.0000000000, 0.0000000000))
           ]"
        , ( "[| (1 + cos(PI/4)) / 3 |]", "0.0000000000", "[| cos(PI/4) / 3 |]")
        , ( "[| cos(PI/4)*2 + 2 |]", "[| cos(PI/4)*2 + 2 |]", "[| cos(PI/4)*2 + 2 |]")
        , 1
        )
      ; ( "test004"
        , "[ ((0.00000, 0.00000, 0.00000), (1.00000, -0.00000, -0.00000), (1.00000, 1.00000, 0.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 1.00000, 0.00000), (1.00000, 1.00000, -0.00000))
           ; ((0.00000, 0.00000, 1.00000), (1.00000, 0.00000, 1.00000), (1.00000, 1.00000, 1.00000))
           ; ((0.00000, 0.00000, 1.00000), (0.00000, 1.00000, 1.00000), (1.00000, 1.00000, 1.00000))
           ; (([| cos(PI/4) |], 0.00000, [| cos(PI/4) |]), (1.00000, 0.00000, 0.00000), (1.00000, 0.00000, [| cos(PI/4)*2 - 1 |]))
           ; (([| cos(PI/4) |], 0.00000, [| cos(PI/4) |]), (1.00000, 0.00000, [| cos(PI/4)*2 - 1 |]), (1.00000, 0.00000, 1.00000))
           ; ((0.00000, 0.00000, 0.00000), ([| cos(PI/4) |], 0.00000, [| cos(PI/4) |]), (1.00000, 0.00000, 0.00000))
           ; ((0.00000, 0.00000, 1.00000), ([| cos(PI/4) |], 0.00000, [| cos(PI/4) |]), (1.00000, 0.00000, 1.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 0.00000, 1.00000), ([| cos(PI/4) |], 0.00000, [| cos(PI/4) |]))
           ; ((0.00000, 1.00000, 0.00000), ([| cos(PI/4) |], 1.00000, [| cos(PI/4) |]), (1.00000, 1.00000, 0.00000))
           ; (([| cos(PI/4) |], 1.00000, [| cos(PI/4) |]), (1.00000, 1.00000, 0.00000), (1.00000, 1.00000, [| cos(PI/4)*2 - 1 |]))
           ; (([| cos(PI/4) |], 1.00000, [| cos(PI/4) |]), (1.00000, 1.00000, [| cos(PI/4)*2 - 1 |]), (1.00000, 1.00000, 1.00000))
           ; ((0.00000, 1.00000, 0.00000), (0.00000, 1.00000, 1.00000), ([| cos(PI/4) |], 1.00000, [| cos(PI/4) |]))
           ; ((0.00000, 1.00000, 1.00000), ([| cos(PI/4) |], 1.00000, [| cos(PI/4) |]), (1.00000, 1.00000, 1.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 1.00000, 0.00000), (0.00000, 1.00000, 1.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 0.00000, 1.00000), (0.00000, 1.00000, 1.00000))
           ; ((1.00000, 0.00000, 0.00000), (1.00000, [| cos(PI/4)*2 - 1 |], [| cos(PI/4)*2 - 1 |]), (1.00000, 1.00000, 0.00000))
           ; ((1.00000, [| cos(PI/4)*2 - 1 |], [| cos(PI/4)*2 - 1 |]), (1.00000, 1.00000, 0.00000), (1.00000, 1.00000, [| cos(PI/4)*2 - 1 |]))
           ; ((1.00000, [| cos(PI/4)*2 - 1 |], [| cos(PI/4)*2 - 1 |]), (1.00000, 1.00000, [| cos(PI/4)*2 - 1 |]), (1.00000, 1.00000, 1.00000))
           ; ((1.00000, 0.00000, [| cos(PI/4)*2 - 1 |]), (1.00000, 0.00000, 1.00000), (1.00000, 1.00000, 1.00000))
           ; ((1.00000, 0.00000, 0.00000), (1.00000, 0.00000, [| cos(PI/4)*2 - 1 |]), (1.00000, [| cos(PI/4)*2 - 1 |], [| cos(PI/4)*2 - 1 |]))
           ; ((1.00000, 0.00000, [| cos(PI/4)*2 - 1 |]), (1.00000, [| cos(PI/4)*2 - 1 |], [| cos(PI/4)*2 - 1 |]), (1.00000, 1.00000, 1.00000))
           ]"
        , ( "[| (1 + cos(PI/4)) / 3 |]", "0.0000000000", "[| cos(PI/4) / 3 |]")
        , ( "[| cos(PI/4)*2 + 2 |]", "[| cos(PI/4)*2 + 2 |]", "[| cos(PI/4)*2 + 2 |]")
        , 2
        )
      ; ( "test005"
        , "[ ((0.00000, 0.00000, 0.00000), (1.00000, -0.00000, -0.00000), (1.00000, 1.00000, 0.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 1.00000, 0.00000), (1.00000, 1.00000, -0.00000))
           ; ((0.00000, 0.00000, 1.00000), (1.00000, 0.00000, 1.00000), (1.00000, 1.00000, 1.00000))
           ; ((0.00000, 0.00000, 1.00000), (0.00000, 1.00000, 1.00000), (1.00000, 1.00000, 1.00000))
           ; (([| cos(PI/4) |], 0.00000, [| cos(PI/4) |]), (1.00000, 0.00000, 0.00000), (1.00000, 0.00000, [| 2*cos(PI/4) - 1 |]))
           ; (([| cos(PI/4) |], 0.00000, [| cos(PI/4) |]), (1.00000, 0.00000, [| cos(PI/4)*2 - 1 |]), (1.00000, 0.00000, 1.00000))
           ; ((0.00000, 0.00000, 0.00000), ([| cos(PI/4) |], 0.00000, [| cos(PI/4) |]), (1.00000, 0.00000, 0.00000))
           ; ((0.00000, 0.00000, 1.00000), ([| cos(PI/4) |], 0.00000, [| cos(PI/4) |]), (1.00000, 0.00000, 1.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 0.00000, 1.00000), ([| cos(PI/4) |], 0.00000, [| cos(PI/4) |]))
           ; ((0.00000, 1.00000, 0.00000), ([| cos(PI/4) |], 1.00000, [| cos(PI/4) |]), (1.00000, 1.00000, 0.00000))
           ; (([| cos(PI/4) |], 1.00000, [| cos(PI/4) |]), (1.00000, 1.00000, 0.00000), (1.00000, 1.00000, [| 2*cos(PI/4) - 1 |]))
           ; (([| cos(PI/4) |], 1.00000, [| cos(PI/4) |]), (1.00000, 1.00000, [| 2*cos(PI/4) - 1 |]), (1.00000, 1.00000, 1.00000))
           ; ((0.00000, 1.00000, 0.00000), (0.00000, 1.00000, 1.00000), ([| cos(PI/4) |], 1.00000, [| cos(PI/4) |]))
           ; ((0.00000, 1.00000, 1.00000), ([| cos(PI/4) |], 1.00000, [| cos(PI/4) |]), (1.00000, 1.00000, 1.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 1.00000, 0.00000), (0.00000, 1.00000, 1.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 0.00000, 1.00000), (0.00000, 1.00000, 1.00000))
           ; ((1.00000, 0.00000, 0.00000), (1.00000, [| 2*cos(PI/4) - 1 |], [| 2*cos(PI/4) - 1 |]), (1.00000, 1.00000, 0.00000))
           ; ((1.00000, [| 2*cos(PI/4) - 1 |], [| 2*cos(PI/4) - 1 |]), (1.00000, 1.00000, 0.00000), (1.00000, 1.00000, [| 2*cos(PI/4) - 1 |]))
           ; ((1.00000, [| 2*cos(PI/4) - 1 |], [| 2*cos(PI/4) - 1 |]), (1.00000, 1.00000, [| 2*cos(PI/4) - 1 |]), (1.00000, 1.00000, 1.00000))
           ; ((1.00000, 0.00000, [| 2*cos(PI/4) - 1 |]), (1.00000, 0.00000, 1.00000), (1.00000, 1.00000, 1.00000))
           ; ((1.00000, 0.00000, 0.00000), (1.00000, 0.00000, [| 2*cos(PI/4) - 1 |]), (1.00000, [| 2*cos(PI/4) - 1 |], [| 2*cos(PI/4) - 1 |]))
           ; ((1.00000, 0.00000, [| 2*cos(PI/4) - 1 |]), (1.00000, [| 2*cos(PI/4) - 1 |], [| 2*cos(PI/4) - 1 |]), (1.00000, 1.00000, 1.00000))
           ]"
        , ( "[| (1 + cos(PI/4)) / 3 |]", "0.0000000000", "[| cos(PI/4) / 3 |]")
        , ( "[| cos(PI/4)*2 + 2 |]", "[| cos(PI/4)*2 + 2 |]", "[| cos(PI/4)*2 + 2 |]")
        , 2
        )
      ]

  (* Mesh3 splits tests *)
  let test_split_identity group (nm, m1, m2, expected) =
    let m1 = M3Parse.of_string m1 in
    let m2 = M3Parse.of_string m2 in
    let (m1', m2') = M.splits (m1, m2)  in
    let actual = M.equiv m1' m2' in
    check_outcome_eq group nm expected actual

  let _ =
    register4 "Mesh3.splits" test_split_identity
      [ ( "test001"
        , "[ ((0.0, 0.0, 0.0), (1.0, 0.0, 0.0), (1.0, 1.0, 0.0))
           ; ((0.0, 0.0, 0.0), (1.0, 1.0, 0.0), (0.0, 1.0, 0.0))
           ; ((0.0, 0.0, 1.0), (1.0, 0.0, 1.0), (1.0, 1.0, 1.0))
           ; ((0.0, 0.0, 1.0), (1.0, 1.0, 1.0), (0.0, 1.0, 1.0))
           ; ((0.0, 0.0, 0.0), (1.0, 0.0, 0.0), (1.0, 0.0, 1.0))
           ; ((0.0, 0.0, 0.0), (1.0, 0.0, 1.0), (0.0, 0.0, 1.0))
           ; ((0.0, 1.0, 0.0), (1.0, 1.0, 0.0), (1.0, 1.0, 1.0))
           ; ((0.0, 1.0, 0.0), (1.0, 1.0, 1.0), (0.0, 1.0, 1.0))
           ; ((0.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 1.0, 1.0))
           ; ((0.0, 0.0, 0.0), (0.0, 1.0, 1.0), (0.0, 0.0, 1.0))
           ; ((1.0, 0.0, 0.0), (1.0, 1.0, 0.0), (1.0, 1.0, 1.0))
           ; ((1.0, 0.0, 0.0), (1.0, 1.0, 1.0), (1.0, 0.0, 1.0))
           ]"
        , "[ ((0.0, 0.0, 0.0), (1.0, 0.0, 0.0), (0.0, 1.0, 0.0))
           ; ((0.0, 1.0, 0.0), (1.0, 1.0, 0.0), (1.0, 0.0, 0.0))
           ; ((0.0, 0.0, 1.0), (1.0, 0.0, 1.0), (0.0, 1.0, 1.0))
           ; ((0.0, 1.0, 1.0), (1.0, 1.0, 1.0), (1.0, 0.0, 1.0))
           ; ((0.0, 0.0, 0.0), (1.0, 0.0, 0.0), (0.0, 0.0, 1.0))
           ; ((0.0, 0.0, 1.0), (1.0, 0.0, 1.0), (1.0, 0.0, 0.0))
           ; ((0.0, 1.0, 0.0), (1.0, 1.0, 0.0), (1.0, 1.0, 1.0))
           ; ((0.0, 1.0, 0.0), (1.0, 1.0, 1.0), (0.0, 1.0, 1.0))
           ; ((0.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 1.0, 1.0))
           ; ((0.0, 0.0, 0.0), (0.0, 1.0, 1.0), (0.0, 0.0, 1.0))
           ; ((1.0, 0.0, 0.0), (1.0, 1.0, 0.0), (1.0, 1.0, 1.0))
           ; ((1.0, 0.0, 0.0), (1.0, 1.0, 1.0), (1.0, 0.0, 1.0))
           ]"
        ,
        true
        )
      ]

  (* Mesh3 cycle extraction *)
  let test_cycle_from_path group (nm, m, expected) =
    let m = M3Parse.of_file m in
    let cs = M.cycles m in
    let actual = List.length cs in
    check_outcome_eq group nm expected actual

  let _ =
    register3 "Mesh3.cycles_from_path" test_cycle_from_path
      [ ( "test001"
        , "test/mesh3/hexhold3.mesh3"
        , 1
        )
      ; ( "test002"
        , "test/mesh3/full_icfp.mesh3"
        , 4
        )
      ]

  (* Mesh3 cycle extraction *)
  let test_cycle group (nm, m, expected) =
    let m = M3Parse.of_string m in
    let cs = M.cycles m in
    let actual = List.length cs in
    check_outcome_eq group nm expected actual

  let _ =
    register3 "Mesh3.cycles" test_cycle
      [ ( "test001"
        , "[ ((0.0, 0.0, 0.0), (1.0, 0.0, 0.0), (1.0, 1.0, 0.0))
           ; ((0.0, 0.0, 0.0), (1.0, 1.0, 0.0), (0.0, 1.0, 0.0))
           ; ((0.0, 0.0, 1.0), (1.0, 0.0, 1.0), (1.0, 1.0, 1.0))
           ; ((0.0, 0.0, 1.0), (1.0, 1.0, 1.0), (0.0, 1.0, 1.0))
           ; ((0.0, 0.0, 0.0), (1.0, 0.0, 0.0), (1.0, 0.0, 1.0))
           ; ((0.0, 0.0, 0.0), (1.0, 0.0, 1.0), (0.0, 0.0, 1.0))
           ; ((0.0, 1.0, 0.0), (1.0, 1.0, 0.0), (1.0, 1.0, 1.0))
           ; ((0.0, 1.0, 0.0), (1.0, 1.0, 1.0), (0.0, 1.0, 1.0))
           ; ((0.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 1.0, 1.0))
           ; ((0.0, 0.0, 0.0), (0.0, 1.0, 1.0), (0.0, 0.0, 1.0))
           ; ((1.0, 0.0, 0.0), (1.0, 1.0, 0.0), (1.0, 1.0, 1.0))
           ; ((1.0, 0.0, 0.0), (1.0, 1.0, 1.0), (1.0, 0.0, 1.0))
           ]"
        , 1
        )
      ; ( "test002"
        , "[ ((0.00000, 0.00000, 0.00000), (1.00000, 0.00000, 0.00000), (1.00000, 1.00000, 0.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 1.00000, 0.00000), (1.00000, 1.00000, 0.00000))
           ; ((0.00000, 0.00000, 1.00000), (1.00000, 0.00000, 1.00000), (1.00000, 1.00000, 1.00000))
           ; ((0.00000, 0.00000, 1.00000), (0.00000, 1.00000, 1.00000), (1.00000, 1.00000, 1.00000))
           ; ((0.00000, 0.00000, 0.00000), (1.00000, 0.00000, 0.00000), (1.00000, 0.00000, 1.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 0.00000, 1.00000), (1.00000, 0.00000, 1.00000))
           ; ((0.00000, 1.00000, 0.00000), (1.00000, 1.00000, 0.00000), (1.00000, 1.00000, 1.00000))
           ; ((0.00000, 1.00000, 0.00000), (0.00000, 1.00000, 1.00000), (1.00000, 1.00000, 1.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 1.00000, 0.00000), (0.00000, 1.00000, 1.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 0.00000, 1.00000), (0.00000, 1.00000, 1.00000))
           ; ((1.00000, 0.00000, 0.00000), (1.00000, 1.00000, 0.00000), (1.00000, 1.00000, 1.00000))
           ; ((1.00000, 0.00000, 0.00000), (1.00000, 0.00000, 1.00000), (1.00000, 1.00000, 1.00000))
           ; ((5.00000, 0.00000, 0.00000), (6.00000, 0.00000, 0.00000), (6.00000, 1.00000, 0.00000))
           ; ((5.00000, 0.00000, 0.00000), (5.00000, 1.00000, 0.00000), (6.00000, 1.00000, 0.00000))
           ; ((5.00000, 0.00000, 1.00000), (6.00000, 0.00000, 1.00000), (6.00000, 1.00000, 1.00000))
           ; ((5.00000, 0.00000, 1.00000), (5.00000, 1.00000, 1.00000), (6.00000, 1.00000, 1.00000))
           ; ((5.00000, 0.00000, 0.00000), (6.00000, 0.00000, 0.00000), (6.00000, 0.00000, 1.00000))
           ; ((5.00000, 0.00000, 0.00000), (5.00000, 0.00000, 1.00000), (6.00000, 0.00000, 1.00000))
           ; ((5.00000, 1.00000, 0.00000), (6.00000, 1.00000, 0.00000), (6.00000, 1.00000, 1.00000))
           ; ((5.00000, 1.00000, 0.00000), (5.00000, 1.00000, 1.00000), (6.00000, 1.00000, 1.00000))
           ; ((5.00000, 0.00000, 0.00000), (5.00000, 1.00000, 0.00000), (5.00000, 1.00000, 1.00000))
           ; ((5.00000, 0.00000, 0.00000), (5.00000, 0.00000, 1.00000), (5.00000, 1.00000, 1.00000))
           ; ((6.00000, 0.00000, 0.00000), (6.00000, 1.00000, 0.00000), (6.00000, 1.00000, 1.00000))
           ; ((6.00000, 0.00000, 0.00000), (6.00000, 0.00000, 1.00000), (6.00000, 1.00000, 1.00000))
           ]"
        , 2
        )
      ; ( "test003"
        , "[ ((0.00000, 0.00000, 0.00000), (1.00000, 0.00000, 0.00000), (1.00000, 1.00000, 0.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 1.00000, 0.00000), (1.00000, 1.00000, 0.00000))
           ; ((0.00000, 0.00000, 1.00000), (1.00000, 0.00000, 1.00000), (1.00000, 1.00000, 1.00000))
           ; ((0.00000, 0.00000, 1.00000), (0.00000, 1.00000, 1.00000), (1.00000, 1.00000, 1.00000))
           ; ((0.00000, 0.00000, 0.00000), (1.00000, 0.00000, 0.00000), (1.00000, 0.00000, 1.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 0.00000, 1.00000), (1.00000, 0.00000, 1.00000))
           ; ((0.00000, 1.00000, 0.00000), (1.00000, 1.00000, 0.00000), (1.00000, 1.00000, 1.00000))
           ; ((0.00000, 1.00000, 0.00000), (0.00000, 1.00000, 1.00000), (1.00000, 1.00000, 1.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 1.00000, 0.00000), (0.00000, 1.00000, 1.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 0.00000, 1.00000), (0.00000, 1.00000, 1.00000))
           ; ((1.00000, 0.00000, 0.00000), (1.00000, 1.00000, 0.00000), (1.00000, 1.00000, 1.00000))
           ; ((1.00000, 0.00000, 0.00000), (1.00000, 0.00000, 1.00000), (1.00000, 1.00000, 1.00000))
           ; ((1.00000, 1.00000, 0.00000), (2.00000, 1.00000, 0.00000), (2.00000, 2.00000, 0.00000))
           ; ((1.00000, 1.00000, 0.00000), (1.00000, 2.00000, 0.00000), (2.00000, 2.00000, 0.00000))
           ; ((1.00000, 1.00000, 1.00000), (2.00000, 1.00000, 1.00000), (2.00000, 2.00000, 1.00000))
           ; ((1.00000, 1.00000, 1.00000), (1.00000, 2.00000, 1.00000), (2.00000, 2.00000, 1.00000))
           ; ((1.00000, 1.00000, 0.00000), (2.00000, 1.00000, 0.00000), (2.00000, 1.00000, 1.00000))
           ; ((1.00000, 1.00000, 0.00000), (1.00000, 1.00000, 1.00000), (2.00000, 1.00000, 1.00000))
           ; ((1.00000, 2.00000, 0.00000), (2.00000, 2.00000, 0.00000), (2.00000, 2.00000, 1.00000))
           ; ((1.00000, 2.00000, 0.00000), (1.00000, 2.00000, 1.00000), (2.00000, 2.00000, 1.00000))
           ; ((1.00000, 1.00000, 0.00000), (1.00000, 2.00000, 0.00000), (1.00000, 2.00000, 1.00000))
           ; ((1.00000, 1.00000, 0.00000), (1.00000, 1.00000, 1.00000), (1.00000, 2.00000, 1.00000))
           ; ((2.00000, 1.00000, 0.00000), (2.00000, 2.00000, 0.00000), (2.00000, 2.00000, 1.00000))
           ; ((2.00000, 1.00000, 0.00000), (2.00000, 1.00000, 1.00000), (2.00000, 2.00000, 1.00000))
           ]"
        , 2
        )
      ; ( "test004"
        , "[ ((0.00000, 0.00000, 0.00000), (1.00000, 0.00000, 0.00000), (1.00000, 1.00000, 0.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 1.00000, 0.00000), (1.00000, 1.00000, 0.00000))
           ; ((0.00000, 0.00000, 1.00000), (1.00000, 0.00000, 1.00000), (1.00000, 1.00000, 1.00000))
           ; ((0.00000, 0.00000, 1.00000), (0.00000, 1.00000, 1.00000), (1.00000, 1.00000, 1.00000))
           ; ((0.00000, 0.00000, 0.00000), (1.00000, 0.00000, 0.00000), (1.00000, 0.00000, 1.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 0.00000, 1.00000), (1.00000, 0.00000, 1.00000))
           ; ((0.00000, 1.00000, 0.00000), (1.00000, 1.00000, 0.00000), (1.00000, 1.00000, 1.00000))
           ; ((0.00000, 1.00000, 0.00000), (0.00000, 1.00000, 1.00000), (1.00000, 1.00000, 1.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 1.00000, 0.00000), (0.00000, 1.00000, 1.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 0.00000, 1.00000), (0.00000, 1.00000, 1.00000))
           ; ((1.00000, 0.00000, 0.00000), (1.00000, 1.00000, 0.00000), (1.00000, 1.00000, 1.00000))
           ; ((1.00000, 0.00000, 0.00000), (1.00000, 0.00000, 1.00000), (1.00000, 1.00000, 1.00000))
           ; ((1.00000, 1.00000, 1.00000), (2.00000, 1.00000, 1.00000), (2.00000, 2.00000, 1.00000))
           ; ((1.00000, 1.00000, 1.00000), (1.00000, 2.00000, 1.00000), (2.00000, 2.00000, 1.00000))
           ; ((1.00000, 1.00000, 2.00000), (2.00000, 1.00000, 2.00000), (2.00000, 2.00000, 2.00000))
           ; ((1.00000, 1.00000, 2.00000), (1.00000, 2.00000, 2.00000), (2.00000, 2.00000, 2.00000))
           ; ((1.00000, 1.00000, 1.00000), (2.00000, 1.00000, 1.00000), (2.00000, 1.00000, 2.00000))
           ; ((1.00000, 1.00000, 1.00000), (1.00000, 1.00000, 2.00000), (2.00000, 1.00000, 2.00000))
           ; ((1.00000, 2.00000, 1.00000), (2.00000, 2.00000, 1.00000), (2.00000, 2.00000, 2.00000))
           ; ((1.00000, 2.00000, 1.00000), (1.00000, 2.00000, 2.00000), (2.00000, 2.00000, 2.00000))
           ; ((1.00000, 1.00000, 1.00000), (1.00000, 2.00000, 1.00000), (1.00000, 2.00000, 2.00000))
           ; ((1.00000, 1.00000, 1.00000), (1.00000, 1.00000, 2.00000), (1.00000, 2.00000, 2.00000))
           ; ((2.00000, 1.00000, 1.00000), (2.00000, 2.00000, 1.00000), (2.00000, 2.00000, 2.00000))
           ; ((2.00000, 1.00000, 1.00000), (2.00000, 1.00000, 2.00000), (2.00000, 2.00000, 2.00000))
           ]"
        , 2
        )
      ; ( "cuboid with hole"
        , " [ ((0.0000000000, 0.0000000000, 0.0000000000), (2.0000000000, 0.0000000000, 0.0000000000), (2.0000000000, 2.0000000000, 0.0000000000))
            ; ((0.0000000000, 0.0000000000, 0.0000000000), (0.0000000000, 2.0000000000, 0.0000000000), (2.0000000000, 2.0000000000, 0.0000000000))
            ; ((0.0000000000, 0.0000000000, 2.0000000000), (2.0000000000, 0.0000000000, 2.0000000000), (2.0000000000, 2.0000000000, 2.0000000000))
            ; ((0.0000000000, 0.0000000000, 2.0000000000), (0.0000000000, 2.0000000000, 2.0000000000), (2.0000000000, 2.0000000000, 2.0000000000))
            ; ((0.0000000000, 0.0000000000, 0.0000000000), (0.5000000000, 0.0000000000, 0.5000000000), (2.0000000000, 0.0000000000, 0.0000000000))
            ; ((0.5000000000, 0.0000000000, 0.5000000000), (1.5000000000, 0.0000000000, 0.5000000000), (2.0000000000, 0.0000000000, 0.0000000000))
            ; ((1.5000000000, 0.0000000000, 0.5000000000), (1.5000000000, 0.0000000000, 1.5000000000), (2.0000000000, 0.0000000000, 2.0000000000))
            ; ((1.5000000000, 0.0000000000, 0.5000000000), (2.0000000000, 0.0000000000, 0.0000000000), (2.0000000000, 0.0000000000, 2.0000000000))
            ; ((0.0000000000, 0.0000000000, 0.0000000000), (0.0000000000, 0.0000000000, 2.0000000000), (0.5000000000, 0.0000000000, 0.5000000000))
            ; ((0.0000000000, 0.0000000000, 2.0000000000), (0.5000000000, 0.0000000000, 1.5000000000), (2.0000000000, 0.0000000000, 2.0000000000))
            ; ((0.0000000000, 0.0000000000, 2.0000000000), (0.5000000000, 0.0000000000, 0.5000000000), (0.5000000000, 0.0000000000, 1.5000000000))
            ; ((0.5000000000, 0.0000000000, 1.5000000000), (1.5000000000, 0.0000000000, 1.5000000000), (2.0000000000, 0.0000000000, 2.0000000000))
            ; ((0.0000000000, 2.0000000000, 0.0000000000), (1.5000000000, 2.0000000000, 0.5000000000), (2.0000000000, 2.0000000000, 0.0000000000))
            ; ((1.5000000000, 2.0000000000, 0.5000000000), (2.0000000000, 2.0000000000, 0.0000000000), (2.0000000000, 2.0000000000, 2.0000000000))
            ; ((0.0000000000, 2.0000000000, 0.0000000000), (0.5000000000, 2.0000000000, 0.5000000000), (1.1666666667, 2.0000000000, 0.5000000000))
            ; ((1.5000000000, 2.0000000000, 1.1000000000), (1.5000000000, 2.0000000000, 1.1666666667), (2.0000000000, 2.0000000000, 2.0000000000))
            ; ((1.5000000000, 2.0000000000, 1.1666666667), (1.5000000000, 2.0000000000, 1.5000000000), (2.0000000000, 2.0000000000, 2.0000000000))
            ; ((0.0000000000, 2.0000000000, 0.0000000000), (1.1666666667, 2.0000000000, 0.5000000000), (1.5000000000, 2.0000000000, 0.5000000000))
            ; ((1.5000000000, 2.0000000000, 0.5000000000), (1.5000000000, 2.0000000000, 1.1000000000), (2.0000000000, 2.0000000000, 2.0000000000))
            ; ((0.0000000000, 2.0000000000, 0.0000000000), (0.0000000000, 2.0000000000, 2.0000000000), (0.5000000000, 2.0000000000, 0.5000000000))
            ; ((0.0000000000, 2.0000000000, 2.0000000000), (1.5000000000, 2.0000000000, 1.5000000000), (2.0000000000, 2.0000000000, 2.0000000000))
            ; ((0.0000000000, 2.0000000000, 2.0000000000), (1.1666666667, 2.0000000000, 1.5000000000), (1.5000000000, 2.0000000000, 1.5000000000))
            ; ((0.0000000000, 2.0000000000, 2.0000000000), (0.5000000000, 2.0000000000, 0.5000000000), (0.5000000000, 2.0000000000, 1.1666666667))
            ; ((0.0000000000, 2.0000000000, 2.0000000000), (0.5000000000, 2.0000000000, 1.1666666667), (0.5000000000, 2.0000000000, 1.5000000000))
            ; ((0.0000000000, 2.0000000000, 2.0000000000), (0.5000000000, 2.0000000000, 1.5000000000), (1.1666666667, 2.0000000000, 1.5000000000))
            ; ((0.0000000000, 0.0000000000, 0.0000000000), (0.0000000000, 2.0000000000, 0.0000000000), (0.0000000000, 2.0000000000, 2.0000000000))
            ; ((0.0000000000, 0.0000000000, 0.0000000000), (0.0000000000, 0.0000000000, 2.0000000000), (0.0000000000, 2.0000000000, 2.0000000000))
            ; ((2.0000000000, 0.0000000000, 0.0000000000), (2.0000000000, 2.0000000000, 0.0000000000), (2.0000000000, 2.0000000000, 2.0000000000))
            ; ((2.0000000000, 0.0000000000, 0.0000000000), (2.0000000000, 0.0000000000, 2.0000000000), (2.0000000000, 2.0000000000, 2.0000000000))
            ; ((0.5000000000, 0.0000000000, 0.5000000000), (1.1666666667, 2.0000000000, 0.5000000000), (1.5000000000, 2.0000000000, 0.5000000000))
            ; ((0.5000000000, 0.0000000000, 0.5000000000), (1.5000000000, 0.0000000000, 0.5000000000), (1.5000000000, 2.0000000000, 0.5000000000))
            ; ((0.5000000000, 0.0000000000, 0.5000000000), (0.5000000000, 2.0000000000, 0.5000000000), (1.1666666667, 2.0000000000, 0.5000000000))
            ; ((0.5000000000, 0.0000000000, 1.5000000000), (1.5000000000, 0.0000000000, 1.5000000000), (1.5000000000, 2.0000000000, 1.5000000000))
            ; ((0.5000000000, 0.0000000000, 1.5000000000), (1.1666666667, 2.0000000000, 1.5000000000), (1.5000000000, 2.0000000000, 1.5000000000))
            ; ((0.5000000000, 0.0000000000, 1.5000000000), (0.5000000000, 2.0000000000, 1.5000000000), (1.1666666667, 2.0000000000, 1.5000000000))
            ; ((0.5000000000, 0.0000000000, 0.5000000000), (0.5000000000, 2.0000000000, 0.5000000000), (0.5000000000, 2.0000000000, 1.1666666667))
            ; ((0.5000000000, 0.0000000000, 0.5000000000), (0.5000000000, 0.0000000000, 1.5000000000), (0.5000000000, 2.0000000000, 1.1666666667))
            ; ((0.5000000000, 0.0000000000, 1.5000000000), (0.5000000000, 2.0000000000, 1.1666666667), (0.5000000000, 2.0000000000, 1.5000000000))
            ; ((1.5000000000, 0.0000000000, 0.5000000000), (1.5000000000, 2.0000000000, 1.1000000000), (1.5000000000, 2.0000000000, 1.1666666667))
            ; ((1.5000000000, 0.0000000000, 0.5000000000), (1.5000000000, 2.0000000000, 0.5000000000), (1.5000000000, 2.0000000000, 1.1000000000))
            ; ((1.5000000000, 0.0000000000, 0.5000000000), (1.5000000000, 2.0000000000, 1.1666666667), (1.5000000000, 2.0000000000, 1.5000000000))
            ; ((1.5000000000, 0.0000000000, 0.5000000000), (1.5000000000, 0.0000000000, 1.5000000000), (1.5000000000, 2.0000000000, 1.5000000000))
            ]"
        , 1
        )
      ; ( "p_subs"
        , "[ ((0.2999990000, 0.0000000000, 0.0000000000), (0.2999990000, 0.2999990000, 0.0000000000), (0.2999990000, 0.2999990000, 1.0000000000))
           ; ((0.2999990000, 0.0000000000, 0.0000000000), (0.2999990000, 0.0000000000, 1.0000000000), (0.2999990000, 0.2999990000, 1.0000000000))
           ; ((0.2999990000, 0.2999990000, 1.0000000000), (1.3000000000, 0.0000000000, 1.0000000000), (1.3000000000, 0.2999990000, 1.0000000000))
           ; ((0.2999990000, 0.0000000000, 1.0000000000), (0.2999990000, 0.2999990000, 1.0000000000), (1.3000000000, 0.0000000000, 1.0000000000))
           ; ((1.3000000000, 0.0000000000, 1.0000000000), (1.3000000000, 0.2999990000, 0.0000000000), (1.3000000000, 0.2999990000, 1.0000000000))
           ; ((1.3000000000, 0.0000000000, 0.0000000000), (1.3000000000, 0.0000000000, 1.0000000000), (1.3000000000, 0.2999990000, 0.0000000000))
           ; ((0.2999990000, 0.0000000000, 0.0000000000), (1.3000000000, 0.0000000000, 0.0000000000), (1.3000000000, 0.2999990000, 0.0000000000))
           ; ((0.2999990000, 0.0000000000, 0.0000000000), (0.2999990000, 0.2999990000, 0.0000000000), (1.3000000000, 0.2999990000, 0.0000000000))
           ; ((0.2999990000, 0.0000000000, 0.0000000000), (0.2999990000, 0.0000000000, 1.0000000000), (1.3000000000, 0.0000000000, 1.0000000000))
           ; ((0.2999990000, 0.0000000000, 0.0000000000), (1.3000000000, 0.0000000000, 0.0000000000), (1.3000000000, 0.0000000000, 1.0000000000))
           ; ((0.2999990000, 0.2999990000, 1.0000000000), (1.3000000000, 0.2999990000, 0.0000000000), (1.3000000000, 0.2999990000, 1.0000000000))
           ; ((0.2999990000, 0.2999990000, 0.0000000000), (0.2999990000, 0.2999990000, 1.0000000000), (1.3000000000, 0.2999990000, 0.0000000000))
           ; ((0.2999990000, 0.5000000000, 0.0000000000), (0.2999990000, 0.7999990000, 0.0000000000), (0.2999990000, 0.7999990000, 1.0000000000))
           ; ((0.2999990000, 0.5000000000, 0.0000000000), (0.2999990000, 0.5000000000, 1.0000000000), (0.2999990000, 0.7999990000, 1.0000000000))
           ; ((0.2999990000, 0.7999990000, 1.0000000000), (0.7999990000, 0.5000000000, 1.0000000000), (0.7999990000, 0.7999990000, 1.0000000000))
           ; ((0.2999990000, 0.5000000000, 1.0000000000), (0.2999990000, 0.7999990000, 1.0000000000), (0.7999990000, 0.5000000000, 1.0000000000))
           ; ((0.7999990000, 0.5000000000, 1.0000000000), (0.7999990000, 0.7999990000, 0.0000000000), (0.7999990000, 0.7999990000, 1.0000000000))
           ; ((0.7999990000, 0.5000000000, 0.0000000000), (0.7999990000, 0.5000000000, 1.0000000000), (0.7999990000, 0.7999990000, 0.0000000000))
           ; ((0.2999990000, 0.5000000000, 0.0000000000), (0.7999990000, 0.5000000000, 0.0000000000), (0.7999990000, 0.7999990000, 0.0000000000))
           ; ((0.2999990000, 0.5000000000, 0.0000000000), (0.2999990000, 0.7999990000, 0.0000000000), (0.7999990000, 0.7999990000, 0.0000000000))
           ; ((0.2999990000, 0.5000000000, 0.0000000000), (0.2999990000, 0.5000000000, 1.0000000000), (0.7999990000, 0.5000000000, 1.0000000000))
           ; ((0.2999990000, 0.5000000000, 0.0000000000), (0.7999990000, 0.5000000000, 0.0000000000), (0.7999990000, 0.5000000000, 1.0000000000))
           ; ((0.2999990000, 0.7999990000, 1.0000000000), (0.7999990000, 0.7999990000, 0.0000000000), (0.7999990000, 0.7999990000, 1.0000000000))
           ; ((0.2999990000, 0.7999990000, 0.0000000000), (0.2999990000, 0.7999990000, 1.0000000000), (0.7999990000, 0.7999990000, 0.0000000000))
           ]"
        , 2
        )
      ]

  (* Mesh3 convex split tests *)
  let test_convex_split group (nm, m', expected) =
    let m = M3Parse.of_file m' in
    let v = M.convex_split m in
    let actual =
      match v with
      | None -> N.n0
      | Some (p1, p2) ->
          print_endline "p1 p2";
          Util.to_file "part1.stl" (M.to_stl p1);
          Util.to_file "part2.stl" (M.to_stl p2);
          N.n2
    in
    check_outcome_eq group nm (N.of_string expected) actual

  let _ =
    register3 "Mesh3.convex_split" test_convex_split
      [ ( "test001"
        , "test/mesh3/threespheres.mesh3"
        , "2"
        )
      ; ( "test002"
        , "test/mesh3/finerspheres.mesh3"
        , "2"
        )
      ; ( "test003"
        , "test/mesh3/unit.mesh3"
        , "0"
        )
      ; ( "test004"
        , "test/mesh3/coarsespheres.mesh3"
        , "2"
        )
      ]

  (* Mesh3 volume tests *)
  let test_vol group (nm, m', expected) =
    let m = M3Parse.of_string m' in
    let v = M.vol m in
    check_outcome_equiv group nm N.equiv (N.of_string expected) v

  let _ =
    register3 "Mesh3.vol" test_vol
      [ ( "test001"
        , "[ ((0, 0, 0), (1, 0, 0), (1, 1, 0))
           ; ((0, 0, 0), (1, 1, 0), (0, 1, 0))
           ; ((0, 0, 1), (1, 1, 1), (1, 0, 1))
           ; ((0, 0, 1), (1, 1, 1), (0, 1, 1))
           ; ((0, 0, 0), (1, 0, 0), (1, 0, 1))
           ; ((0, 0, 0), (1, 0, 1), (0, 0, 1))
           ; ((0, 1, 0), (1, 1, 0), (1, 1, 1))
           ; ((0, 1, 0), (1, 1, 1), (0, 1, 1))
           ; ((0, 0, 0), (0, 1, 1), (0, 1, 0))
           ; ((0, 0, 0), (0, 1, 1), (0, 0, 1))
           ; ((1, 0, 0), (1, 1, 0), (1, 1, 1))
           ; ((1, 0, 0), (1, 1, 1), (1, 0, 1))
           ]"
        , "1.0"
        )
      ]

  (* Mesh3 euler tests *)
  let test_euler group (nm, n1', n2', n3', expected) =
    let intern_pt pt = Util.triple_map num_of_string pt in
    let n1 = intern_pt n1' in
    let n2 = intern_pt n2' in
    let n3 = intern_pt n3' in
    let exp = Util.uncurry3 G.mkpt (intern_pt expected) in
    let actual = Util.uncurry3 G.mkpt (M.euler n1 n2 n3) in
    check_outcome_equiv group nm G.equiv_pt exp actual

  let _ =
    register5 "Mesh3.euler" test_euler
      [ ( "test001"
        , ("[| cos(PI/4) |]", "[| - sin(PI/4) |]", "0")
        , ("[| sin(PI/4) |]", "[| cos(PI/4) |]", "0")
        , ("0", "0", "1")
        , ("0", "0", "-45")
        )
      ; ( "test002"
        , ("[| cos(PI/6) |]", "[| sin(PI/6) |]", "0")
        , ("[| -sin(PI/6) |]", "[| cos(PI/6) |]", "0")
        , ("0", "0", "1")
        , ("0.0", "0.0", "30.0")
        )
      ; ( "test003"
        , ("1.0", "0.0", "0.0")
        , ("0.0", "1.0", "0.0")
        , ("0.0", "0.0", "1.0")
        , ("0.0", "0.0", "0.0")
        )
      ; ( "test004"
        , ("1", "0", "0")
        , ("0", "[| cos(PI/6) |]", "[| -sin(PI/6) |]")
        , ("0", "[| sin(PI/6) |]", "[| cos(PI/6) |]")
        , ("-30.0", "0.0", "0.0")
        )
      ; ( "test005"
        , ("[| cos(PI/6) |]", "0",  "[| sin(PI/6) |]")
        , ("0", "1", "0")
        , ("[| -sin(PI/6) |]", "0", "[| cos(PI/6) |]")
        , ("0.0", "-30.0", "0.0")
        )
      ]

  (* Mesh3 face_splits tests *)
  let test_face_splits group (nm, m, (p11, p12, p13), expected) =
    let m = M3Parse.of_string m in
    let (pt1, pt2, pt3) =
      Util.triple_map
        (Util.triple_map num_of_string)
          (p11, p12, p13)
    in
    let f = M.face (pt1, pt2, pt3) in
    let ls = M.face_splits (List.map M.face (M.faces m)) f in
    check_outcome_eq group nm expected (List.length ls)

  let _ =
    register4 "Mesh3.face_splits" test_face_splits
      [ ( "test001"
        , "[ ((0.00000, 0.00000, 0.00000), ([| cos(PI/4) |], 0.00000, [| -cos(PI/4) |]), ([| cos(PI/4) |], 1.00000, [| -cos(PI/4) |]))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 1.00000, 0.00000), ([| cos(PI/4) |], 1.00000, [| -cos(PI/4) |]))
           ; (([| cos(PI/4) |], 0.00000, [| cos(PI/4) |]), ([| 2*cos(PI/4) |], 0.00000, 0.00000), ([| 2*cos(PI/4) |], 1.00000, 0.00000))
           ; (([| cos(PI/4) |], 0.00000, [| cos(PI/4) |]), ([| cos(PI/4) |], 1.00000, [| cos(PI/4) |]), ([| 2*cos(PI/4) |], 1.00000, 0.00000))
           ; ((0.00000, 0.00000, 0.00000), ([| cos(PI/4) |], 0.00000, [| -cos(PI/4) |]), ([| 2*cos(PI/4) |], 0.00000, 0.00000))
           ; ((0.00000, 0.00000, 0.00000), ([| cos(PI/4) |], 0.00000, [| cos(PI/4) |]), ([| 2*cos(PI/4) |], 0.00000, 0.00000))
           ; ((0.00000, 1.00000, 0.00000), ([| cos(PI/4) |], 1.00000, [| -cos(PI/4) |]), ([| 2*cos(PI/4) |], 1.00000, 0.00000))
           ; ((0.00000, 1.00000, 0.00000), ([| cos(PI/4) |], 1.00000, [| cos(PI/4) |]), ([| 2*cos(PI/4) |], 1.00000, 0.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 1.00000, 0.00000), ([| cos(PI/4) |], 1.00000, [| cos(PI/4) |]))
           ; ((0.00000, 0.00000, 0.00000), ([| cos(PI/4) |], 0.00000, [| cos(PI/4) |]), ([| cos(PI/4) |], 1.00000, [| cos(PI/4) |]))
           ; (([| cos(PI/4) |], 0.00000, [| -cos(PI/4) |]), ([| cos(PI/4) |], 1.00000, [| -cos(PI/4) |]), ([| 2*cos(PI/4) |], 1.00000, 0.00000))
           ; (([| cos(PI/4) |], 0.00000, [| -cos(PI/4) |]), ([| 2*cos(PI/4) |], 0.00000, 0.00000), ([| 2*cos(PI/4) |], 1.00000, 0.00000))
        ]"
        , ( ("1.0", "0.0", "0.0")
          , ("[| cos(PI/4) |]", "0.0", "[| cos(PI/4) |]")
          , ("1.0", "0.0", "1.0")
          )
        , 2
        )
      ; ( "test002"
        , "[ ((0.0, 0.0, 0.0), (1.0, 0.0, 0.0), (1.0, 1.0, 0.0))
           ; ((0.0, 0.0, 0.0), (1.0, 1.0, 0.0), (0.0, 1.0, 0.0))
           ; ((0.0, 0.0, 1.0), (1.0, 0.0, 1.0), (1.0, 1.0, 1.0))
           ; ((0.0, 0.0, 1.0), (1.0, 1.0, 1.0), (0.0, 1.0, 1.0))
           ; ((0.0, 0.0, 0.0), (1.0, 0.0, 0.0), (1.0, 0.0, 1.0))
           ; ((0.0, 0.0, 0.0), (1.0, 0.0, 1.0), (0.0, 0.0, 1.0))
           ; ((0.0, 1.0, 0.0), (1.0, 1.0, 0.0), (1.0, 1.0, 1.0))
           ; ((0.0, 1.0, 0.0), (1.0, 1.0, 1.0), (0.0, 1.0, 1.0))
           ; ((0.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 1.0, 1.0))
           ; ((0.0, 0.0, 0.0), (0.0, 1.0, 1.0), (0.0, 0.0, 1.0))
           ; ((1.0, 0.0, 0.0), (1.0, 1.0, 0.0), (1.0, 1.0, 1.0))
           ; ((1.0, 0.0, 0.0), (1.0, 1.0, 1.0), (1.0, 0.0, 1.0))
           ]"
        , ( ("1.0", "0.0", "0.0")
          , ("[| cos(PI/4) |]", "0.0", "[| cos(PI/4) |]")
          , ("1.0", "0.0", "1.0")
          )
        , 1
        )
      ]

  let test_face_mem group (nm, m, f, expected) =
    let m = M3Parse.of_string m in
    let f =
      f |> Util.triple_map (Util.triple_map num_of_string)
        |> M.face
    in check_outcome_eq group nm expected (M.face_mem m f)

  let _ =
    register4 "Mesh3.face_mem" test_face_mem
      [ ( "test001"
        , "[ ((0.00000, 0.00000, 0.00000), (1.00000, -0.00000, -0.00000), (1.00000, 1.00000, 0.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 1.00000, 0.00000), (1.00000, 1.00000, -0.00000))
           ; ((0.00000, 0.00000, 1.00000), (1.00000, 0.00000, 1.00000), (1.00000, 1.00000, 1.00000))
           ; ((0.00000, 0.00000, 1.00000), (0.00000, 1.00000, 1.00000), (1.00000, 1.00000, 1.00000))
           ; (([| cos(PI/4) |], 0.00000, [| cos(PI/4) |]), (1.00000, 0.00000, 0.00000), (1.00000, 0.00000, [| cos(PI/4)*2 - 1 |]))
           ; (([| cos(PI/4) |], 0.00000, [| cos(PI/4) |]), (1.00000, 0.00000, [| cos(PI/4)*2 - 1 |]), (1.00000, 0.00000, 1.00000))
           ; ((0.00000, 0.00000, 0.00000), ([| cos(PI/4) |], 0.00000, [| cos(PI/4) |]), (1.00000, 0.00000, 0.00000))
           ; ((0.00000, 0.00000, 1.00000), ([| cos(PI/4) |], 0.00000, [| cos(PI/4) |]), (1.00000, 0.00000, 1.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 0.00000, 1.00000), ([| cos(PI/4) |], 0.00000, [| cos(PI/4) |]))
           ; ((0.00000, 1.00000, 0.00000), ([| cos(PI/4) |], 1.00000, [| cos(PI/4) |]), (1.00000, 1.00000, 0.00000))
           ; (([| cos(PI/4) |], 1.00000, [| cos(PI/4) |]), (1.00000, 1.00000, 0.00000), (1.00000, 1.00000, [| cos(PI/4)*2 - 1 |]))
           ; (([| cos(PI/4) |], 1.00000, [| cos(PI/4) |]), (1.00000, 1.00000, [| cos(PI/4)*2 - 1 |]), (1.00000, 1.00000, 1.00000))
           ; ((0.00000, 1.00000, 0.00000), (0.00000, 1.00000, 1.00000), ([| cos(PI/4) |], 1.00000, [| cos(PI/4) |]))
           ; ((0.00000, 1.00000, 1.00000), ([| cos(PI/4) |], 1.00000, [| cos(PI/4) |]), (1.00000, 1.00000, 1.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 1.00000, 0.00000), (0.00000, 1.00000, 1.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 0.00000, 1.00000), (0.00000, 1.00000, 1.00000))
           ; ((1.00000, 0.00000, 0.00000), (1.00000, [| cos(PI/4)*2 - 1 |], [| cos(PI/4)*2 - 1 |]), (1.00000, 1.00000, 0.00000))
           ; ((1.00000, [| cos(PI/4)*2 - 1 |], [| cos(PI/4)*2 - 1 |]), (1.00000, 1.00000, 0.00000), (1.00000, 1.00000, [| cos(PI/4)*2 - 1 |]))
           ; ((1.00000, [| cos(PI/4)*2 - 1 |], [| cos(PI/4)*2 - 1 |]), (1.00000, 1.00000, [| cos(PI/4)*2 - 1 |]), (1.00000, 1.00000, 1.00000))
           ; ((1.00000, 0.00000, [| cos(PI/4)*2 - 1 |]), (1.00000, 0.00000, 1.00000), (1.00000, 1.00000, 1.00000))
           ; ((1.00000, 0.00000, 0.00000), (1.00000, 0.00000, [| cos(PI/4)*2 - 1 |]), (1.00000, [| cos(PI/4)*2 - 1 |], [| cos(PI/4)*2 - 1 |]))
           ; ((1.00000, 0.00000, [| cos(PI/4)*2 - 1 |]), (1.00000, [| cos(PI/4)*2 - 1 |], [| cos(PI/4)*2 - 1 |]), (1.00000, 1.00000, 1.00000))
           ]"
        , ( ("0.0", "0.0", "0.0")
          , ("0.0", "1.0", "0.0")
          , ("[| cos(PI/4) |]", "1.0", "[| cos(PI/4) |]")
          )
        , M.In
        )
      ; ( "test002"
        , "[ ((0.00000, 0.00000, 0.00000), (1.00000, 0.00000, 0.00000), (1.00000, 1.00000, 0.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 1.00000, 0.00000), (1.00000, 1.00000, 0.00000))
           ; ((0.00000, 0.00000, 1.00000), (1.00000, 0.00000, 1.00000), (1.00000, 1.00000, 1.00000))
           ; ((0.00000, 0.00000, 1.00000), (0.00000, 1.00000, 1.00000), (1.00000, 1.00000, 1.00000))
           ; ((0.00000, 0.00000, 0.00000), (1.00000, 0.00000, 0.00000), (1.00000, 0.00000, 1.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 0.00000, 1.00000), (1.00000, 0.00000, 1.00000))
           ; ((0.00000, 1.00000, 0.00000), (1.00000, 1.00000, 0.00000), (1.00000, 1.00000, 1.00000))
           ; ((0.00000, 1.00000, 0.00000), (0.00000, 1.00000, 1.00000), (1.00000, 1.00000, 1.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 1.00000, 0.00000), (0.00000, 1.00000, 1.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 0.00000, 1.00000), (0.00000, 1.00000, 1.00000))
           ; ((1.00000, 0.00000, 0.00000), (1.00000, 1.00000, 0.00000), (1.00000, 1.00000, 1.00000))
           ; ((1.00000, 0.00000, 0.00000), (1.00000, 0.00000, 1.00000), (1.00000, 1.00000, 1.00000))
           ]"
        , ( ("0.0", "0.0", "0.0")
          , ("0.0", "1.0", "0.0")
          , ("[| cos(PI/4) |]", "1.0", "[| cos(PI/4) |]")
          )
        , M.In
        )
      ; ( "test003"
        , "[ ((0.00000, 0.00000, 0.00000), (1.00000, 0.00000, 0.00000), (1.00000, 1.00000, 0.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 1.00000, 0.00000), (1.00000, 1.00000, 0.00000))
           ; ((0.00000, 0.00000, 1.00000), (0.49858, 0.49858, 1.00000), (1.00000, 0.00000, 1.00000))
           ; ((0.49858, 0.49858, 1.00000), (1.00000, 0.14054, 1.00000), (1.00000, 0.49858, 1.00000))
           ; ((0.49858, 0.49858, 1.00000), (1.00000, 0.00000, 1.00000), (1.00000, 0.14054, 1.00000))
           ; ((0.49858, 0.49858, 1.00000), (1.00000, 0.49858, 1.00000), (1.00000, 1.00000, 1.00000))
           ; ((0.00000, 0.49858, 1.00000), (0.00000, 1.00000, 1.00000), (0.49858, 0.49858, 1.00000))
           ; ((0.00000, 0.14054, 1.00000), (0.00000, 0.49858, 1.00000), (0.49858, 0.49858, 1.00000))
           ; ((0.00000, 0.00000, 1.00000), (0.00000, 0.14054, 1.00000), (0.49858, 0.49858, 1.00000))
           ; ((0.00000, 1.00000, 1.00000), (0.49858, 0.49858, 1.00000), (1.00000, 1.00000, 1.00000))
           ; ((0.00000, 0.00000, 0.00000), (1.00000, 0.00000, 0.00000), (1.00000, 0.00000, 1.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 0.00000, 1.00000), (1.00000, 0.00000, 1.00000))
           ; ((0.00000, 1.00000, 0.00000), (1.00000, 1.00000, 0.00000), (1.00000, 1.00000, 1.00000))
           ; ((0.00000, 1.00000, 0.00000), (0.00000, 1.00000, 1.00000), (1.00000, 1.00000, 1.00000))
           ; ((0.00000, 0.79864, 0.60182), (0.00000, 1.00000, 0.00000), (0.00000, 1.00000, 1.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 0.79864, 0.60182), (0.00000, 1.00000, 0.00000))
           ; ((0.00000, 0.71406, 0.71406), (0.00000, 0.79864, 0.60182), (0.00000, 1.00000, 1.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 0.71406, 0.71406), (0.00000, 0.79864, 0.60182))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 0.00000, 1.00000), (0.00000, 0.14054, 1.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 0.14054, 1.00000), (0.00000, 0.49858, 1.00000))
           ; ((0.00000, 0.49858, 1.00000), (0.00000, 0.71406, 0.71406), (0.00000, 1.00000, 1.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 0.49858, 1.00000), (0.00000, 0.71406, 0.71406))
           ; ((1.00000, 0.79864, 0.60182), (1.00000, 1.00000, 0.00000), (1.00000, 1.00000, 1.00000))
           ; ((1.00000, 0.00000, 0.00000), (1.00000, 0.79864, 0.60182), (1.00000, 1.00000, 0.00000))
           ; ((1.00000, 0.71406, 0.71406), (1.00000, 0.79864, 0.60182), (1.00000, 1.00000, 1.00000))
           ; ((1.00000, 0.00000, 0.00000), (1.00000, 0.71406, 0.71406), (1.00000, 0.79864, 0.60182))
           ; ((1.00000, 0.00000, 0.00000), (1.00000, 0.00000, 1.00000), (1.00000, 0.14054, 1.00000))
           ; ((1.00000, 0.00000, 0.00000), (1.00000, 0.14054, 1.00000), (1.00000, 0.49858, 1.00000))
           ; ((1.00000, 0.49858, 1.00000), (1.00000, 0.71406, 0.71406), (1.00000, 1.00000, 1.00000))
           ; ((1.00000, 0.00000, 0.00000), (1.00000, 0.49858, 1.00000), (1.00000, 0.71406, 0.71406))
           ]"
        , ( ("0.0", "0.67601", "0.67601")
          , ("0.0", "0.71406", "0.71406")
          , ("0.0", "0.49858", "1.0")
          )
        , let f pt = pt |> Util.triple_map num_of_string
          in
          M.On [ M.face ( f ("0.0", "0.71406", "0.71406")
                        , f ("0.0", "0.49858", "1.0"    )
                        , f ("0.0", "0.0",     "0.0"    )
                        )
               ]
        )
      ]

  let test_norm group (nm, m, f, expected) =
    let m = M3Parse.of_string m in
    let f =
      f |> Util.triple_map (Util.triple_map num_of_string)
        |> M.face
    in
    check_outcome_eq
      ~output_to_string:M.string_of_norm
      group nm expected (M.norm m f)

  let _ =
    register4 "Mesh3.norm" test_norm
      [ ( "test001"
        , "[ ((0.00000, 0.00000, 0.00000), (1.00000, 0.00000, 0.00000), (1.00000, 1.00000, 0.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 1.00000, 0.00000), (1.00000, 1.00000, 0.00000))
           ; ((0.00000, 0.00000, 1.00000), (0.49858, 0.49858, 1.00000), (1.00000, 0.00000, 1.00000))
           ; ((0.49858, 0.49858, 1.00000), (1.00000, 0.14054, 1.00000), (1.00000, 0.49858, 1.00000))
           ; ((0.49858, 0.49858, 1.00000), (1.00000, 0.00000, 1.00000), (1.00000, 0.14054, 1.00000))
           ; ((0.49858, 0.49858, 1.00000), (1.00000, 0.49858, 1.00000), (1.00000, 1.00000, 1.00000))
           ; ((0.00000, 0.49858, 1.00000), (0.00000, 1.00000, 1.00000), (0.49858, 0.49858, 1.00000))
           ; ((0.00000, 0.14054, 1.00000), (0.00000, 0.49858, 1.00000), (0.49858, 0.49858, 1.00000))
           ; ((0.00000, 0.00000, 1.00000), (0.00000, 0.14054, 1.00000), (0.49858, 0.49858, 1.00000))
           ; ((0.00000, 1.00000, 1.00000), (0.49858, 0.49858, 1.00000), (1.00000, 1.00000, 1.00000))
           ; ((0.00000, 0.00000, 0.00000), (1.00000, 0.00000, 0.00000), (1.00000, 0.00000, 1.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 0.00000, 1.00000), (1.00000, 0.00000, 1.00000))
           ; ((0.00000, 1.00000, 0.00000), (1.00000, 1.00000, 0.00000), (1.00000, 1.00000, 1.00000))
           ; ((0.00000, 1.00000, 0.00000), (0.00000, 1.00000, 1.00000), (1.00000, 1.00000, 1.00000))
           ; ((0.00000, 0.79864, 0.60182), (0.00000, 1.00000, 0.00000), (0.00000, 1.00000, 1.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 0.79864, 0.60182), (0.00000, 1.00000, 0.00000))
           ; ((0.00000, 0.71406, 0.71406), (0.00000, 0.79864, 0.60182), (0.00000, 1.00000, 1.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 0.71406, 0.71406), (0.00000, 0.79864, 0.60182))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 0.00000, 1.00000), (0.00000, 0.14054, 1.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 0.14054, 1.00000), (0.00000, 0.49858, 1.00000))
           ; ((0.00000, 0.49858, 1.00000), (0.00000, 0.71406, 0.71406), (0.00000, 1.00000, 1.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 0.49858, 1.00000), (0.00000, 0.71406, 0.71406))
           ; ((1.00000, 0.79864, 0.60182), (1.00000, 1.00000, 0.00000), (1.00000, 1.00000, 1.00000))
           ; ((1.00000, 0.00000, 0.00000), (1.00000, 0.79864, 0.60182), (1.00000, 1.00000, 0.00000))
           ; ((1.00000, 0.71406, 0.71406), (1.00000, 0.79864, 0.60182), (1.00000, 1.00000, 1.00000))
           ; ((1.00000, 0.00000, 0.00000), (1.00000, 0.71406, 0.71406), (1.00000, 0.79864, 0.60182))
           ; ((1.00000, 0.00000, 0.00000), (1.00000, 0.00000, 1.00000), (1.00000, 0.14054, 1.00000))
           ; ((1.00000, 0.00000, 0.00000), (1.00000, 0.14054, 1.00000), (1.00000, 0.49858, 1.00000))
           ; ((1.00000, 0.49858, 1.00000), (1.00000, 0.71406, 0.71406), (1.00000, 1.00000, 1.00000))
           ; ((1.00000, 0.00000, 0.00000), (1.00000, 0.49858, 1.00000), (1.00000, 0.71406, 0.71406))
           ]"
        , ( ("0", "0",       "0")
          , ("0", "0.49858", "1")
          , ("0", "0.71406", "0.71406"))
        , M.R
        )
      ]

  let test_denote' group (nm, m, pt, expected) =
    let m = M3Parse.of_string m in
    let pt = pt |> Util.triple_map num_of_string
                |> Util.uncurry3 G.mkpt
    in
    check_outcome_eq group nm expected (M.denote' m pt)

  let _ =
    register4 "Mesh3.denote'" test_denote'
      [ ( "test001"
        , "[ ((0.00000, 0.00000, 0.00000), (1.00000, 0.00000, 0.00000), (1.00000, 1.00000, 0.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 1.00000, 0.00000), (1.00000, 1.00000, 0.00000))
           ; ((0.00000, 0.00000, 1.00000), (1.00000, 0.00000, 1.00000), (1.00000, 1.00000, 1.00000))
           ; ((0.00000, 0.00000, 1.00000), (0.00000, 1.00000, 1.00000), (1.00000, 1.00000, 1.00000))
           ; ((0.00000, 0.00000, 0.00000), (1.00000, 0.00000, 0.00000), (1.00000, 0.00000, 1.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 0.00000, 1.00000), (1.00000, 0.00000, 1.00000))
           ; ((0.00000, 1.00000, 0.00000), (1.00000, 1.00000, 0.00000), (1.00000, 1.00000, 1.00000))
           ; ((0.00000, 1.00000, 0.00000), (0.00000, 1.00000, 1.00000), (1.00000, 1.00000, 1.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 1.00000, 0.00000), (0.00000, 1.00000, 1.00000))
           ; ((0.00000, 0.00000, 0.00000), (0.00000, 0.00000, 1.00000), (0.00000, 1.00000, 1.00000))
           ; ((1.00000, 0.00000, 0.00000), (1.00000, 1.00000, 0.00000), (1.00000, 1.00000, 1.00000))
           ; ((1.00000, 0.00000, 0.00000), (1.00000, 0.00000, 1.00000), (1.00000, 1.00000, 1.00000))
           ]"
        , ("[| cos(PI/4) / 3 |]", "[| 2/3 |]", "[| cos(PI/4) / 3 |]")
        , M.In
        )
      ]

end

module TestGeom3 = struct
  module G   = G3

  let intern_pt pt =
    pt |> Util.triple_map num_of_string
       |> Util.uncurry3 G.mkpt

  let intern_tri t =
    t |> Util.triple_map intern_pt
      |> Util.uncurry3 G.mktri

  let intern_dseg s =
    s |> Util.pair_map intern_pt
      |> Util.uncurry G.mkdseg

  let intern_ray r =
    r |> intern_dseg
      |> G.mkray

  let intern_plane p =
    p |> Util.triple_map intern_pt
      |> Util.uncurry3 G.mkplane

  let intern_line l =
    l |> Util.pair_map intern_pt
      |> Util.uncurry G.mkline

  let intern_tdron ts =
    match List.map intern_tri ts with
    | [a; b; c; d] -> G.mktdron a b c d
    | _ -> failwith "intern_tdron: expected 4 triangles"

  (* Geom3 coplanar tests *)
  let test_coplanar group (nm, p1, p2, p3, p4, expected) =
    let actual =
      string_of_bool
        (G.coplanar
          (intern_pt p1)
          (intern_pt p2)
          (intern_pt p3)
          (intern_pt p4))
    in
    check_outcome_eq group nm expected actual

  let _ =
    register6 "Geom3.coplanar" test_coplanar
      [ ( "test001"
        , ("0.0", "0.0", "0.0")
        , ("1.0", "0.0", "1.0")
        , ("1.0", "0.0", "0.0")
        , ("[| 2*cos(PI/4) |]", "0.0", "0.0")
        , "true"
        )
      ; ( "test002"
        , ("0.0", "0.0", "0.0")
        , ("1.0", "0.0", "1.0")
        , ("1.0", "0.0", "0.0")
        , ("[| cos(PI/4) |]", "0.0", "[| cos(PI/4) |]")
        , "true"
        )
      ; ( "test003"
        , ("0.0", "0.0", "0.0")
        , ("1.0", "0.0", "1.0")
        , ("[| 2*cos(PI/4) |]", "0.0", "0.0")
        , ("[| cos(PI/4) |]", "0.0", "[| cos(PI/4) |]")
        , "true"
        )
      ]

  (* Geom3 on_dseg tests *)
  let test_on_dseg group (nm, s, pt, expected) =
    let actual = G.on_dseg (intern_dseg s) (intern_pt pt) in
    check_outcome_eq group nm expected actual

  let _ =
    register4 "Geom3.on_dseg" test_on_dseg
      [ ( "test001"
        , ( ("0.0", "0.0", "0.0")
          , ("1.0", "1.0", "1.0")
          )
        , ("0.0", "0.0", "0.0")
        , true
        )
      ; ( "test002"
        , ( ("0.0", "0.0", "0.0")
          , ("1.0", "1.0", "1.0")
          )
        , ("1.0", "1.0", "1.0")
        , true
        )
      ; ( "test003"
        , ( ("0.0", "0.0", "0.0")
          , ("1.0", "1.0", "1.0")
          )
        , ("1.0", "1.5", "1.5")
        , false
        )
      ; ( "test004"
        , ( ("0.6719387648", "0.6931896212", "0.0000000000")
          , ("0.7694208843", "0.5590169944", "0.0000000000")
          )
        , ("0.6808812905", "0.6808812905", "0.0000000000")
        , false
        )
      ; ( "test005"
        , ( ("-0.0000000000", "[| - cos(PI/6) |]", "0.0000000000")
          , (" 0.5453926444", " -0.4063878754", "0.2946221438")
          )
        , ("0.5478003419", "-0.4043587535", "0.2959227866")
        , false
        )
      ; ( "test006"
        , ( ("-0.0000000000", "-0.2886751346", "-0.8164965809")
          , (" 0.5453926444", "-0.4063878754", " 0.2946221438")
          )
        , ("0.5478003419", "-0.4043587535", "0.2959227866")
        , false
        )
      ; ( "test007"
        , ( ("-0.0000000000", "-0.2886751346", "-0.8164965809")
          , (" 0.5478200176", "-0.4043629086", " 0.2959627420")
          )
        , ("0.5478003419", "-0.4043587535", "0.2959227866")
        , true
        )
      ; ( "test008"
        , ( (" 0.5453926444", "-0.4063878754", " 0.2946221438")
          , (" 0.5478200176", "-0.4043629086", " 0.2959627420")
          )
        , ("0.5478003419", "-0.4043587535", "0.2959227866")
        , false
        )
      ; ( "test009"
        , ( ("0.4285714286", "2.1428571429", "0.0000000000")
          , ("1.0000000000", "2.3333333333", "0.0000000000")
          )
        , ("0.4285714286", "2.1428571429", "0.0000000000")
        , true
        )
      ; ( "test010"
        , ( ("1.0", "0.0", "0.0")
          , ("0.0", "1.0", "0.0")
          )
        , ("0.5", "0.5", "0.0")
        , true
        )
      ]

  (* Geom3 isect_rs tests *)
  let test_isect_rs group (nm, s, r, expected) =
    let actual =
      G.string_of_isect_ls
      (G.isect_rs (intern_ray r) (intern_dseg s))
    in
    check_outcome_eq group nm expected actual

  let _ =
    register4 "Geom3.isect_rs" test_isect_rs
      [ ( "test001"
        , ( ("0.0", "0.0", "0.0")
          , ("1.0", "1.0", "1.0")
          )
        , ( ("0.0", "0.0", "0.0")
          , ("1.0", "0.0", "0.0")
          )
        , "SCross"
        )
      ; ( "test002"
        , ( ("0.0", "0.0", "0.0")
          , ("1.0", "1.0", "1.0")
          )
        , ( ("-1.0", "0.0", "0.0")
          , (" 1.0", "0.0", "0.0")
          )
        , "SCross"
        )
      ]

  (* Geom3.in_tdron tests *)
  let test_in_tdron group (nm, t, pt, expected) =
    let actual =
      G.in_tdron (intern_tdron t) (intern_pt pt)
    in
    check_outcome_eq group nm expected actual

  let _ =
    register4 "Geom3.in_tdron" test_in_tdron
      [ ( "test001"
        , [ ( (" 0.0", " 0.0", "5.0")
            , ("-2.5", "-2.0", "0.0")
            , (" 2.5", "-2.0", "0.0"))

          ; ( (" 0.0", " 0.0", "5.0")
            , ("-2.5", "-2.0", "0.0")
            , (" 0.0", " 5.0", "0.0"))

          ; ( ("0.0", " 0.0", "5.0")
            , ("0.0", " 5.0", "0.0")
            , ("2.5", "-2.0", "0.0"))

          ; ( (" 0.0", " 5.0", "0.0")
            , ("-2.5", "-2.0", "0.0")
            , (" 2.5", "-2.0", "0.0"))
          ]
        , ("0.0", "0.0", "5.0")
        , true
        )
      ; ( "test002"
        , [ ( (" 0.0", " 0.0", "5.0")
            , ("-2.5", "-2.0", "0.0")
            , (" 2.5", "-2.0", "0.0"))

          ; ( (" 0.0", " 0.0", "5.0")
            , ("-2.5", "-2.0", "0.0")
            , (" 0.0", " 5.0", "0.0"))

          ; ( ("0.0", " 0.0", "5.0")
            , ("0.0", " 5.0", "0.0")
            , ("2.5", "-2.0", "0.0"))

          ; ( (" 0.0", " 5.0", "0.0")
            , ("-2.5", "-2.0", "0.0")
            , (" 2.5", "-2.0", "0.0"))
          ]
        , (" 2.5", "-2.0", "0.0")
        , true
        )
      ; ( "test003"
        , [ ( (" 0.0", " 0.0", "5.0")
            , ("-2.5", "-2.0", "0.0")
            , (" 2.5", "-2.0", "0.0"))

          ; ( (" 0.0", " 0.0", "5.0")
            , ("-2.5", "-2.0", "0.0")
            , (" 0.0", " 5.0", "0.0"))

          ; ( ("0.0", " 0.0", "5.0")
            , ("0.0", " 5.0", "0.0")
            , ("2.5", "-2.0", "0.0"))

          ; ( (" 0.0", " 5.0", "0.0")
            , ("-2.5", "-2.0", "0.0")
            , (" 2.5", "-2.0", "0.0"))
          ]
        , ("0.0", "0.0", "1.0")
        , true
        )
      ]

  (* Geom3 collinear tests *)
  let test_collinear group (nm, ps, expected) =
    let (p1, p2, p3) = Util.triple_map intern_pt ps in
    let actual = G.collinear p1 p2 p3 in
    let describe_input () =
      Util.string_of_triple
        (Util.triple_map Util.string_of_triple ps)
    in
    let output_to_string = string_of_bool in
    check_outcome_eq
      ~describe_input
      ~output_to_string
      group nm expected actual

  let _ =
    register3 "Geom3.collinear" test_collinear
      [ ( "test001"
        , ( ("0.0", "[| -sin(PI/18) |]", "[| cos(PI/18) |]")
          , ( "0.0"
            , "0.0"
            , "[| (1 - cos(PI/18)) * sin(PI/18) / (tan(7*PI/36) + sin(PI/18)) + cos(PI/18) |]")
          , ("0.0", "[| tan(7*PI/36) |]", "1.0")
          )
        , true
        )
      ; ( "test002"
        , ( ("0", "0.71406", "0.71406")
          , ("0", "0.49858", "1")
          , ("0", "0", "0")
          )
        , false
        )
      ]

  (* Geom3 plane_angle tests *)
  let test_plane_angle group (nm, pA, pB, expected) =
    let actual =
      (intern_plane pB)
        |> G.plane_angle (intern_plane pA)
        |> N.deg_of_rad
    in
    check_outcome_equiv
      ~output_to_string:N.to_string
      group nm N.equiv (N.of_string expected) actual

  let _ =
    register4 "Geom3.plane_angle" test_plane_angle
    [ ( "xy-yz"
      , ( ("0.0", "0.0", "0.0")
        , ("1.0", "1.0", "0.0")
        , ("1.0", "0.0", "0.0")
        )
      , ( ("0.0", "0.0", "0.0")
        , ("0.0", "1.0", "0.0")
        , ("0.0", "0.0", "1.0")
        )
      , "90.0"
      )
    ; ( "xy-45"
      , ( ("0.0", "0.0", "0.0")
        , ("1.0", "1.0", "0.0")
        , ("1.0", "0.0", "0.0")
        )
      , ( ("0.0", "0.0", "0.0")
        , ("0.0", "1.0", "0.0")
        , ("[| cos(PI/6) |]", "0.0", "[| cos(PI/6) |]")
        )
      , "45.0"
      )
    ; ( "xy-neg-yz"
      , ( ("0.0", "0.0", "0.0")
        , ("1.0", "1.0", "0.0")
        , ("1.0", "0.0", "0.0")
        )
      , ( ("0.0", "0.0", "0.0")
        , ("0.0", "1.0", "0.0")
        , ("0.0", "0.0", "-1.0")
        )
      , "90.0"
      )
    ]

  (* Geom3 plane_angle tests to check all angles are acute *)
  let test_plane_angle_acute group (nm, pA, pB, expected) =
    let compare =
      (intern_plane pB)
        |> G.plane_angle (intern_plane pA)
        |> N.deg_of_rad
        |> N.cmp (N.of_string "90.0")
    in
    let actual = compare <> LT in
    check_outcome_eq group nm expected actual

  let _ =
    register4 "Geom3.plane_angle_acute" test_plane_angle_acute
    [ ( "xy-yz"
      , ( ("0.0", "0.0", "0.0")
        , ("1.0", "1.0", "0.0")
        , ("1.0", "0.0", "0.0")
        )
      , ( ("0.0", "0.0", "0.0")
        , ("0.0", "1.0", "0.0")
        , ("0.0", "0.0", "1.0")
        )
      , true
      )
    ; ( "xy-60"
      , ( ("0.0", "0.0", "0.0")
        , ("1.0", "1.0", "0.0")
        , ("1.0", "0.0", "0.0")
        )
      , ( ("0.0", "0.0", "0.0")
        , ("0.0", "1.0", "0.0")
        , ("0.86", "0.0", "0.86")
        )
      , true
      )
    ; ( "random1"
      , ( ("0.6", "0.0", "0.0")
        , ("1.0", "1.0", "12.0")
        , ("1.3", "0.0", "0.076")
        )
      , ( ("0.0", "2.5", "6.0")
        , ("0.2", "1.5", "7.0")
        , ("0.86", "0.0", "0.86")
        )
      , true
      )
    ; ( "random2"
      , ( ("3.67", "4.58", "9.60")
        , ("2.39", "5.66", "2.98")
        , ("1.702", "0.11", "11.90")
        )
      , ( ("4.0", "5.67", "60.55")
        , ("7.34", "72.36", "17.86")
        , ("0.89", "0.0", "0.86")
        )
      , true
      )
    ]

  (* Geom3 equiv_line tests *)
  let test_equiv_line group (nm, lA, lB, expected) =
    let actual = G.equiv_line (intern_line lA) (intern_line lB) in
    check_outcome_eq group nm expected actual

  let _ =
    register4 "Geom3.equiv_line" test_equiv_line
      [
      ]

  (* Geom3 isect_ll tests *)
  let test_isect_ll group (nm, lA, lB, expected) =
    let actual = G.isect_ll (intern_line lA) (intern_line lB) in
    let output_to_string = G.string_of_isect_ln in
    check_outcome_equiv
      ~output_to_string
      group
      nm
      G.isect_line_equiv expected actual

  let _ =
    register4 "Geom3.isect_ll" test_isect_ll
      [ ( "test001"
        , ( ("0.0", "0.0", "0.0")
          , ("1.0", "1.0", "1.0")
          )
        , ( ("0.0", "0.0", "0.0")
          , ("1.0", "0.0", "0.0")
          )
        , G.LCross (intern_pt ("0.0", "0.0", "0.0"))
        )
      ; ( "test002"
        , ( ("4.0", "7.0", "9.0")
          , ("1.0", "1.0", "1.0")
          )
        , ( ("0.5", "0.7", "1.0")
          , ("1.0", "0.2", "9.0")
          )
        , G.LNone
        )
      ; ( "test003"
        , ( ("0.0", "0.0", "0.0")
          , ("1.0", "1.0", "1.0")
          )
        , ( ("0.0", "0.0", "0.0")
          , ("1.0", "1.0", "1.0")
          )
        , G.LOver
        )
      ; ( "test004"
        , ( ("0.0", "0.0", "0.0")
          , ("1.0", "0.0", "1.0")
          )
        , ( ("[| cos(PI/4) |]", "0.0", "[| cos(PI/4) |]")
          , ("[| 2*cos(PI/4) |]", "0.0", "0.0")
          )
        , G.LCross (intern_pt ("[| cos(PI/4) |]", "0.0", "[| cos(PI/4) |]"))
        )
      ; ( "test005"
        , ( ("1.0", "0.0", "0.0")
          , ("1.0", "0.0", "1.0")
          )
        , ( ("[| cos(PI/4) |]", "0.0", "[| cos(PI/4) |]")
          , ("[| 2*cos(PI/4) |]", "0.0", "0.0")
          )
        , G.LCross (intern_pt ("1.0", "0.0", "[| cos(PI/4)*2 - 1 |]"))
        )
      ; ( "test006"
        , ( ("0.0", "0.0", "0.0")
          , ("1.0", "0.0", "0.0")
          )
        , ( ("[| cos(PI/4) |]", "0.0", "[| cos(PI/4) |]")
          , ("[| 2*cos(PI/4) |]", "0.0", "0.0")
          )
        , G.LCross (intern_pt ("[| 2*cos(PI/4) |]", "0.0", "0.0"))
        )
      ; ( "test007"
        , ( ("0.0", "0.0", "0.0")
          , ("1.0", "0.0", "0.0")
          )
        , ( ("[| cos(PI/4) |]", "0.0", "[| cos(PI/4) |]")
          , ("[| 2*cos(PI/4) |]", "0.0", "0.0")
          )
        , G.LCross (intern_pt ("[| 2*cos(PI/4) |]", "0.0", "0.0"))
        )
      ; ( "test008"
        , ( (" 0.5478200176", "-0.4043629086", " 0.2959627420")
          , ("-0.0000000000", "-0.2886751346", "-0.8164965809")
          )
        , ( ("-0.0000000000", "[| - cos(PI/6) |]", "0.0000000000")
          , (" 0.5453926444", " -0.4063878754", "0.2946221438")
          )
        , G.LCross (intern_pt ( " 0.5478200176"
                              , "-0.4043629086"
                              , " 0.2959627420"))
        )
      ]

   (* Geom3 isect_ls tests *)
  let test_isect_ls group (nm, lA, sB, expected) =
    let actual =
      G.string_of_isect_ls
        (G.isect_ls (intern_line lA) (intern_dseg sB))
    in
    check_outcome_eq group nm expected actual

  let _ =
    register4 "Geom3.isect_ls" test_isect_ls
      [ ( "test001"
        , ( ("0.0", "0.0", "0.0")
          , ("1.0", "0.0", "1.0")
          )
        , ( ("[| cos(PI/4) |]", "0.0", "[| cos(PI/4) |]")
          , ("[| 2*cos(PI/4) |]", "0.0", "0.0")
          )
        , "SCross"
        )
      ; ( "test002"
        , ( ( "-0.5000000000", "0.2741139465", "0.4103001725")
          , ( "-0.5000000000", "0.2741401756", "0.4103393954")
          )
        , ( ("-0.5000000000", "-0.5000000000", "0.4103393954")
          , ("-0.5000000000", " 0.2741800183", "0.4103393954")
          )
        , "SCross"
        )
      ; ( "test003"
        , ( ( "-0.5000000000", "0.2741139465", "0.4103001725")
          , ( "-0.5000000000", "0.2741401756", "0.4103393954")
          )
        , ( ("-0.5000000000", "-0.5000000000", "0.4103393954")
          , ("-0.5000000000", " 0.3235163042", "0.4841763651")
          )
        , "SNone"
        )
      ; ( "test004"
        , ( ( "-0.5000000000", "0.2741139465", "0.4103001725")
          , ( "-0.5000000000", "0.2741401756", "0.4103393954")
          )
        , ( ("-0.5000000000", " 0.2741800183", "0.4103393954")
          , ("-0.5000000000", " 0.3235163042", "0.4841763651")
          )
        , "SCross"
        )
      ; ( "test005"
        , ( ("0", "0.5", "0")
          , ("0.5", "-0.5", "1")
          )
        , ( ("0", "0", "0")
          , ("0.7", "0.7", "0.5")
          )
        , "SNone"
        )
      ; ( "test006"
        , ( ("-0.0000000000", "[| - cos(PI/6) |]", "0.0000000000")
          , (" 0.5453926444", " -0.4063878754", "0.2946221438")
          )
        , ( ("-0.0000000000", "-0.2886751346", "-0.8164965809")
          , (" 0.5453926444", "-0.4063878754", " 0.2946221438")
          )
        , "SCross"
        )
      ; ( "test007"
        , ( ("-0.0000000000", "[| - cos(PI/6) |]", "0.0000000000")
          , (" 0.5453926444", " -0.4063878754", "0.2946221438")
          )
        , ( (" 0.5453926444", "-0.4063878754", " 0.2946221438")
          , (" 0.5478200176", "-0.4043629086", " 0.2959627420")
          )
        , "SCross"
        )
      ; ( "test008"
        , ( ("0.0000000000", "0.0000000000", "0.0000000000")
          , ("0.2000000000", "1.0000000000", "0.0000000000")
          )
        , ( ("0.4285714286", "2.1428571429", "0.0000000000")
          , ("1.0000000000", "2.3333333333", "0.0000000000")
          )
        , "SCross"
        )
      ; ( "test009"
        , ( ("0.0000000000", "0.0000000000", "0.0000000000")
          , ("0.2000000000", "1.0000000000", "0.0000000000")
          )
        , ( ("0.4285714286", "2.1428571429", "0.0000000000")
          , ("0.5862068966", "2.1034482759", "0.0000000000")
          )
        , "SCross"
        )
      ; ( "test010"
        , ( ("0.0000000000", "0.0000000000", "0.0000000000")
          , ("0.2000000000", "1.0000000000", "0.0000000000")
          )
        , ( ("0.5862068966", "2.1034482759", "0.0000000000")
          , ("1.0000000000", "2.3333333333", "0.0000000000")
          )
        , "SNone"
        )
      ]

  (* Geom3 equiv_pt tests *)
  let test_equiv_pt group (nm, pt1, pt2, expected) =
    let actual =
      string_of_bool (G.equiv_pt (intern_pt pt1) (intern_pt pt2))
    in
    check_outcome_eq group nm expected actual

  let _ =
    register4 "Geom3.equiv_pt" test_equiv_pt
      [ ( "test001"
        , ("[| -cos(PI/9) |]", "[| sin(PI/9) |]", " 0.0")
        , ( "[| sin(PI/9) - cos(PI/9) |]"
          , "[| cos(PI/9) + sin(PI/9) |]"
          , " 0.0"
          )
        , "false"
        )
      ; ( "test002"
        , (" 0.5453926444", "-0.4063878754", " 0.2946221438")
        , (" 0.5478200176", "-0.4043629086", " 0.2959627420")
        , "false"
        )
      ]

  (* Geom3 on_tri tests *)
  let test_on_tri group (nm, t, pt, expected) =
    let t = intern_tri t in
    let pt = intern_pt pt in
    let actual = G.on_tri t pt in
    let describe_input () =
      Printf.sprintf "%s\n%s"
        (G.string_of_tri t)
        (G.string_of_pt pt)
    in
    let output_to_string = string_of_bool in
    check_outcome_eq
      ~describe_input
      ~output_to_string
      group nm expected actual

  let _ =
    register4 "Geom3.on_tri" test_on_tri
      [ ( "test001"
        , ( ("0.0", "0.0", "0.0")
          , ("1.0", "0.0", "0.0")
          , ("1.0", "1.0", "0.0")
          )
        , ("0.0", "0.0", "5.0")
        , false
        )
      ; ( "test002"
        , ( ("4.0", "7.0", "9.0")
          , ("1.0", "1.0", "1.0")
          , ("0.0", "0.0", "0.0")
          )
        , ("-0.5", "-0.7", "-1.0")
        , false
        )
      ; ( "test003"
        , ( (" 1.0", " 0.0", "0.0")
          , (" 1.0", " 1.0", "0.0")
          , (" 1.0", " 1.0", "1.0")
          )
        , ("1.0", "0.5", " 0.1")
        , true
        )
      ; ( "test004"
        , ( ("0.0", "0.0", "0.0")
          , ("0.0", "1.0", "0.0")
          , ("0.0", "1.0", "1.0")
          )
        , ("0.0", "1.3", "0.5")
        , false
        )
      ; ( "test005"
        , ( ("0.0", "0.0", "0.0")
          , ("0.0", "0.0", "1.0")
          , ("0.0", "1.0", "1.0")
          )
        , ("0.0", "1.3", "0.5")
        , false
        )
      ; ( "test006"
        , ( ("0.0", "0.0", "0.0")
          , ("0.0", "0.0", "1.0")
          , ("1.0", "0.0", "1.0")
          )
        , ("0.0", "-0.0", "-0.0")
        , true
        )
      ; ( "test007"
        , ( ("0.83526403996", "0.53627252489", "0")
          , ("0.84635429229", "0.47287286519", "0")
          , ("0.86250280593", "0.44760092097", "0")
          )
        , ("1", "0", "0")
        , false
        )
      ]

  let test_on_plane group (nm, p, pt, expected) =
    let actual =
      G.on_plane (intern_plane p) (intern_pt pt)
    in
    check_outcome_eq group nm expected actual

  let _ =
    register4 "Geom3.on_plane" test_on_plane
    [ ( "test001"
      , ( ("-0.0000000000", "-0.2886751346", "-0.8164965809")
        , (" 0.5453926444", "-0.4063878754", " 0.2946221438")
        , (" 0.5478200176", "-0.4043629086", " 0.2959627420")
        )
      , ( "-0.0000000000", "[| - cos(PI/6) |]", "0.0000000000")
      , true
      )
    ]

  let test_isect_tl group (nm, t, l, expected) =
    let t = intern_tri t in
    let l = intern_line l in
    let actual = G.isect_tl t l in
    let describe_input () =
      [ G.string_of_tri t
      ; G.string_of_line l
      ] |> String.concat "\n"
    in
    let output_to_string = function
      | G.TLThru pt -> Printf.sprintf "TLThru %s" (G.string_of_pt pt)
      | G.TLCut s -> Printf.sprintf "TLCut %s" (G.string_of_dseg s)
      | G.TLNone -> "TLNone"
    in
    check_outcome_equiv
      ~describe_input
      ~output_to_string
      group nm G.equiv_isect_tl expected actual

  let _ =
    register4 "Geom3.isect_tl" test_isect_tl
      [ ( "test001"
        , ( ( "[| (3*cos(PI/5) + cos(3*PI/10)) / (4*cos(PI/10) + 4*cos(PI/5) + 2*cos(2*PI/5)) |]"
            , "[| (1 + 6*cos(PI/10) - 4*cos(3*PI/10)) / (2*cos(PI/10) + 6*cos(2*PI/5)) |]"
            , "[| 0 |] ")
          , ( "[| (4*cos(PI/5) - 2*cos(3*PI/10)) / (2 + 3*cos(PI/5) + cos(3*PI/10)) |]"
            , "[| 1 + cos(3*PI/10) / (2*cos(PI/10) + 3*cos(PI/5)) |]"
            , "[| 0 |] ")
          , ( "[| cos(PI/10) - cos(2*PI/5) |]"
            , "[| (1 + 2*cos(2*PI/5)) / (cos(PI/10) - cos(2*PI/5)) / 2 |]"
            , "[| 0 |]")
          )
        , ( ( "[| cos(PI/10) / cos(PI/5) - 1 |]"
            , "[| 1/(2*cos(PI/10) - 1) |]"
            , "[| 0 |]")
          , ( "[| (1/22) * (-124 * cos(PI/10) * sin(PI/10) + 60 * cos(PI/10) - 106 * sin(PI/10) + 19) |]"
            , "[| (1/22) * (156 * cos(PI/10) * sin(PI/10) - 40 * cos(PI/10) + 98 * sin(PI/10) - 13) |]"
            , "[| 0 |]")
          )
        , G.TLCut
            (intern_dseg
               ( ( "[| (16372/22041) + (74/79) * cos(PI/10) - (26606/22041) * cos(PI/5) + (92/79) * cos(3*PI/10) - (59884/22041) * cos(2*PI/5) |]"
                 , "[| - (33664/22041) + (144/79) * cos(PI/10) + (31616/22041) * cos(PI/5) - (90/79) * cos(3*PI/10) + (34786/22041) * cos(2*PI/5) |]"
                 , "[| 0 |]"
                 )
               , ( "[| (7255/902)  - 13 * cos(PI/10) + (5373/451) * cos(PI/5) - 10 * cos(3*PI/10) + (1392/451) * cos(2*PI/5) |]"
                 , "[| (8595/902)  - 19 * cos(PI/10) + (7641/451) * cos(PI/5) - 10 * cos(3*PI/10) + (2732/451) * cos(2*PI/5) |]"
                 , "[| 0 |]"
                 )
               ))
        )
      ; ( "test002"
        , ( ("-0.5000000000", "-0.5000000000", "0.4103393954")
          , ("-0.5000000000", " 0.2741800183", "0.4103393954")
          , ("-0.5000000000", " 0.3235163042", "0.4841763651")
          )
        , ( ( "-0.5000000000", "0.2741139465", "0.4103001725")
          , ( "-0.5000000000", "0.2741401756", "0.4103393954")
          )
        , G.TLCut
            (intern_dseg
               ( ( "-0.5"
                 , "0.2741401756"
                 , "0.4103393954"
                 )
               , ( "-0.5"
                 , "0.3234435634"
                 , "0.4840675009"
                 )
               ))
        )
      ; ( "test003"
				, ( ("1.0000000000", "1.0000000000", "0.0000000000")
          , ("1.0000000000", "0.0000000000", "0.0000000000")
          , ("0.0000000000", "0.0000000000", "0.0000000000")
          )
       ,  ( ("1.0000000000", "0.0000000000", "0.0000000000")
          , ("0.0000000000", "0.0000000000", "0.0000000000")
					)
        , G.TLCut
            (intern_dseg
               ( ("1", "0", "0")
               , ("0", "0", "0")
               ))
        )
      ; ( "test004"
				, ( ("1.0000000000", "1.0000000000", "1.0000000000")
          , ("1.0000000000", "0.0000000000", "1.0000000000")
          , ("0.6018616204", "0.0551446507", "1.0000000000")
          )
       ,  ( ("0.5787256924", "0.0000000000", "1.0000000000")
          , ("0.6018616204", "0.0551446507", "1.0000000000")
					)
        , G.TLCut
            (intern_dseg
               ( ("0.6018616204", "0.0551446507", "1.0000000000")
               , ("0.6018616204", "0.0551446507", "1.0000000000")
               ))
        )
      ; ( "test005"
				, ( ("1.0000000000", "1.0000000000", "0.0000000000")
          , ("1.0000000000", "0.0000000000", "0.0000000000")
          , ("0.0000000000", "0.0000000000", "0.0000000000")
          )
       ,  ( ("0.0000000000", "0.0000000000", "0.0000000000")
          , ("0.0000000000", "1.0000000000", "0.0000000000")
					)
        , G.TLCut
            (intern_dseg
               ( ("0.0000000000", "0.0000000000", "0.0000000000")
               , ("0.0000000000", "0.0000000000", "0.0000000000")
               ))
        )
      ; ( "test006"
				, ( ("1.0000000000", "1.0000000000", "0.0000000000")
          , ("1.0000000000", "0.0000000000", "0.0000000000")
          , ("0.0000000000", "0.0000000000", "0.0000000000")
          )
       ,  ( ("0.0000000000", "0.0000000000", "0.0000000000")
          , ("0.0000000000", "1.0000000000", "0.0000000000")
					)
        , G.TLCut
            (intern_dseg
               ( ("0.0000000000", "0.0000000000", "0.0000000000")
               , ("0.0000000000", "0.0000000000", "0.0000000000")
               ))
        )
      ; ( "test007"
				, ( ("1.0000000000", "1.0000000000", "0.0000000000")
          , ("1.0000000000", "0.0000000000", "0.0000000000")
          , ("0.0000000000", "0.0000000000", "0.0000000000")
          )
       ,  ( ("0.0000000000", "0.0000000000", "0.0000000000")
          , ("1.0000000000", "0.0000000000", "0.0000000000")
					)
        , G.TLCut
            (intern_dseg
               ( ("1", "0", "0")
               , ("0", "0", "0")
               ))
        )
     ]

  (* Geom3 isect_ts tests *)
  let test_isect_ts group (nm, t, s, expected) =
    let t = intern_tri t in
    let s = intern_dseg s in
    let actual = G.isect_ts t s in
    let describe_input () =
      [ G.threejs_of_tri "tri" t
      ; G.threejs_of_dseg "seg" s
      ] |> String.concat "\n"
    in
    let output_to_string = function
      | G.TSThru pt ->
          Printf.sprintf "TSThru %s" (G.string_of_pt pt)
      | G.TSCut s   ->
          Printf.sprintf "TSCut %s" (G.string_of_dseg s)
      | G.TSNone    ->
          "TSNone"
    in
    print_endline (G.string_of_isect_ts actual);
    check_outcome_equiv
      ~describe_input
      ~output_to_string
      group nm G.equiv_isect_ts expected actual

  let _ =
    register4 "Geom3.isect_ts" test_isect_ts
      [ ( "test001"
        , ( ("0.0", "0.0", "0.0")
          , ("1.0", "1.0", "1.0")
          , ("1.0", "0.0", "0.0")
          )
        , ( ("0.0", "0.0", "0.0")
          , ("1.0", "0.0", "0.0")
          )
        , G.TSCut
            (intern_dseg
              ( ("0.0", "0.0", "0.0")
              , ("1.0", "0.0", "0.0")))
        )
      ; ( "test002"
        , ( ("4.0", "7.0", "9.0")
          , ("1.0", "1.0", "1.0")
          , ("0.0", "0.0", "0.0")
          )
        , ( ("-0.5", "-0.7", "-1.0")
          , ("-1.0", "-0.2", "-9.0")
          )
        , G.TSNone
        )
      ; ( "test003"
        , ( (" 0.0", " 1.0", "0.0")
          , ("-1.0", " 0.0", "0.0")
          , (" 1.0", " 0.0", "0.0")
          )
        , ( ("0.0", "0.5", " 1.0")
          , ("0.0", "0.5", "-1.0")
          )
        , G.TSThru (intern_pt ("0.0", "0.5", "0.0"))
        )
      ; ( "test004"
        , ( ("[| sin(PI/9) - cos(PI/9) |]", "[| cos(PI/9) + sin(PI/9) |]", "0.0")
          , (" 0.0", " 0.0", "0.0")
          , ("[| sin(PI/9) |]", "[| cos(PI/9) |]", "0.0")
          )
        , ( ("[| -cos(PI/9) |]", "[| sin(PI/9) |]", " 0.0")
          , ("[| sin(PI/9) - cos(PI/9) |]", "[| cos(PI/9) + sin(PI/9) |]", " 0.0")
          )
        , G.TSNone
        )
      ; ( "test005"
        , ( ("1.0", "0.0", "0.0")
          , ("0.7", "0.0", "0.7")
          , ("1.0", "0.0", "1.0")
          )
        , ( ("1.0", "0.0", "1.0")
          , ("1.0", "0.0", "0.4")
          )
        , G.TSCut
            (intern_dseg
              ( ("1.0", "0.0", "0.4")
              , ("1.0", "0.0", "1.0")))
        )
      ; ( "test006"
        , ( ("1.0", "0.0", "0.0")
          , ("0.0", "0.0", "0.0")
          , ("1.0", "0.0", "1.0")
          )
        , ( ("[| cos(PI/4) |]", "0.0", "[| cos(PI/4) |]")
          , ("[| 2*cos(PI/4) |]", "0.0", "0.0")
          )
        , G.TSCut
            (intern_dseg
               ( ("[| cos(PI/4) |]", "0.0", "[| cos(PI/4) |]")
               , ("1.0", "0.0", "[| 2*cos(PI/4) - 1 |]")))
        )
      ; ( "test007"
        , ( ("-0.0000000000", "-0.2886751346", "-0.8164965809")
          , (" 0.5453926444", "-0.4063878754", " 0.2946221438")
          , (" 0.5478200176", "-0.4043629086", " 0.2959627420")
          )
        , ( ( "-0.0000000000", "[| - cos(PI/6) |]", "0.0000000000")
          , ( " 0.5453926444", " -0.4063878754", "0.2946221438")
          )
        , G.TSNone
        )
      ]

  (* Geom3 part_ts tests *)
  let test_part_ts group (nm, t, s, expected) =
    let actual =
      List.length (G.part_ts (intern_tri t) (intern_dseg s))
    in
    let describe_input () =
      Util.string_of_triple
        (Util.triple_map Util.string_of_triple t) ^
      Util.string_of_pair
        (Util.pair_map Util.string_of_triple s)
    in
    let output_to_string = string_of_int in
    check_outcome_eq
      ~describe_input
      ~output_to_string
      group nm expected actual

  let _ =
    register4 "Geom3.part_ts" test_part_ts
      [ ( "test001"
        , ( ( "928.306029334692425436514895409346"
            , "-719.677245262664541769481729716063"
            , "833.741999999999961801222525537014"
            )
          , ( "993.662578412874267996812704950571"
            , "-105.788475487071409020245482679456"
            , "0.000000000000000000000000000000"
            )
          , ( "993.662578412874267996812704950571"
            , "-105.788475487071409020245482679456"
            , "833.741999999999961801222525537014"
            )
          )
        , ( ( "928.306029334692425436514895409346"
            , "-719.677245262664541769481729716063"
            , "0.000000000000000000000000000000"
            )
          , ( "993.662578412874267996812704950571"
            , "-105.788475487071409020245482679456"
            , "0.000000000000000000000000000000"
            )
          )
        , 1
        )
      ]

  (* Geom3 part_tri tests *)
  let test_part_tri group (nm, t1, t2, expected)=
    let t1 = intern_tri t1 in
    let t2 = intern_tri t2 in
    let ps = G.part_tri t1 t2 in
    let actual = List.length ps in
    let describe_input () =
      [ G.string_of_tri t1
      ; G.string_of_tri t2
      ] |> String.concat "\n"
    in
    let output_to_string = string_of_int in
    check_outcome_eq
      ~describe_input
      ~output_to_string
      group nm expected actual

  let _ =
    register4 "Geom3.part_tri" test_part_tri
      [ ( "test001"
        , ( ("0.0", "0.0", "0.0")
          , ("1.0", "0.0", "1.0")
          , ("1.0", "0.0", "0.0")
          )
        , ( ("1.0", "1.0", "1.0")
          , ("1.0", "0.0", "[| tan(2*PI/9) |]")
          , ("1.0", "0.0", "1.0")
          )
        , 1
        )
      ; ( "test002"
        , ( ("1.0", "1.0", "1.0")
          , ("1.0", "0.0", "[| tan(2*PI/9) |]")
          , ("1.0", "0.0", "1.0")
          )
        , ( ("0.0", "0.0", "0.0")
          , ("1.0", "0.0", "1.0")
          , ("1.0", "0.0", "0.0")
          )
        , 2
        )
      ; ( "test003"
        , ( ("1.0", "0.0", "0.0")
          , ("0.7", "0.0", "0.7")
          , ("1.0", "0.0", "1.0")
          )
        , ( ("1.0", "0.0", "0.4")
          , ("1.0", "0.0", "1.0")
          , ("1.0", "1.0", "1.0")
          )
        , 1
        )
      ; ( "test004"
        , ( ("1.0", "0.0", "0.4")
          , ("1.0", "0.0", "1.0")
          , ("1.0", "1.0", "1.0")
          )
        , ( ("1.0", "0.0", "0.0")
          , ("0.7", "0.0", "0.7")
          , ("1.0", "0.0", "1.0")
          )
        , 2
        )
      ; ( "test005"
        , ( ("[| 2*cos(PI/4) |]", "0.0", "0.0")
          , ("[| cos(PI/4) |]", "0.0", "[| cos(PI/4) |]")
          , ("[| 2*cos(PI/4) |]", "1.0", "0.0")
          )
        , ( ("1.0", "0.0", "0.0")
          , ("1.0", "0.0", "1.0")
          , ("0.0", "0.0", "0.0")
          )
        , 3
        )
      ; ( "test006"
        , ( ("[| 2*cos(PI/4) |]", "0.0", "0.0")
          , ("[| cos(PI/4) |]", "0.0", "[| cos(PI/4) |]")
          , ("0.0", "0.0", "0.0")
          )
        , ( ("1.0", "0.0", "0.0")
          , ("1.0", "0.0", "1.0")
          , ("0.0", "0.0", "0.0")
          )
        , 3
        )
      ; ( "test007"
        , ( ("0.00000", "0.000000", "[| 0.1 / cos(PI/6) |]")
          , ("0.00000", "[| cos(PI/6) - 0.5 |]", "[| 0.05 + cos(PI/6)/10 |]")
          , ("[| 0.5 / cos(PI/6) |]", "0.000000", "[| 0.1 / cos(PI/6) |]")
          )
        , ( ("0.00000", "[| 2 * (1 - cos(PI/6)) |]", "0.10000")
          , ("[| 0.5 / cos(PI/6) |]", "[| -cos(PI/6) * 5 / 34 |]", "[| 0.1 / cos(PI/6) |]")
          , ("0.10000", "[| 0.5 - cos(PI/6) |]", "[| 0.05 + cos(PI/6)/10 |]")
          )
        , 2
        )
      ; ( "test008"
        , ( ("0.00000", "[| 2 * (1 - cos(PI/6)) |]", "0.10000")
          , ("[| 0.5 / cos(PI/6) |]", "[| -cos(PI/6) * 5 / 34 |]", "[| 0.1 / cos(PI/6) |]")
          , ("0.10000", "[| 0.5 - cos(PI/6) |]", "[| 0.05 + cos(PI/6)/10 |]")
          )
        , ( ("0.00000", "0.000000", "[| 0.1 / cos(PI/6) |]")
          , ("0.00000", "[| cos(PI/6) - 0.5 |]", "[| 0.05 + cos(PI/6)/10 |]")
          , ("[| 0.5 / cos(PI/6) |]", "0.000000", "[| 0.1 / cos(PI/6) |]")
          )
        , 2
        )
      ; ( "test009"
        , ( ("0.00000", "0.00000", "[| 1 / cos(PI/6) |]")
          , ("0.00000", "[| cos(PI/6) - .5 |]", "[| 0.5 + cos(PI/6) |]")
          , ("[| 0.5 / cos(PI/6) |]", "0.00000", "[| 1 / cos(PI/6) |]")
          )
        , ( ("[| 1 - 0.5 / cos(PI/6) |]", " 0.00000", "[| 1 / cos(PI/6) |]")
          , ("[| 0.5 / cos(PI/6) |]", " 0.00000", "[| 1 / cos(PI/6) |]")
          , ("1.00000", "[| -cos(PI/6) - .5 |]", "[| 0.5 + cos(PI/6) |]")
          )
        , 1
        )
      ; ( "test010"
        , ( ("[| 1 - 0.5 / cos(PI/6) |]", " 0.00000", "[| 1 / cos(PI/6) |]")
          , ("[| 0.5 / cos(PI/6) |]", " 0.00000", "[| 1 / cos(PI/6) |]")
          , ("1.00000", "[| -cos(PI/6) - .5 |]", "[| 0.5 + cos(PI/6) |]")
          )
        , ( ("0.00000", "0.00000", "[| 1 / cos(PI/6) |]")
          , ("0.00000", "[| cos(PI/6) - .5 |]", "[| 0.5 + cos(PI/6) |]")
          , ("[| 0.5 / cos(PI/6) |]", "0.00000", "[| 1 / cos(PI/6) |]")
          )
        , 2
        )
      ; ( "test011"
        , ( ("1.00000", " 0.00000", "[| tan(5*PI/36) |]")
          , ("1.00000", " 0.00000", "[| tan(7*PI/36) |]")
          , ("1.00000", "[| tan(7*PI/36) |]", "[| tan(7*PI/36) |]")
          )
        , ( ("1.00000", "[| tan(7*PI/36) |]", "[| tan(7*PI/36) |]")
          , ("1.00000", "0.43827", "[| tan(7*PI/36) |]")
          , ("0.78021", "0.00000", "0.78021")
          )
        , 1
        )
      ; ( "test012"
        , ( ("1.00000", "[| tan(7*PI/36) |]", "[| tan(7*PI/36) |]")
          , ("1.00000", "0.43827", "[| tan(7*PI/36) |]")
          , ("0.78021", "0.00000", "0.78021")
          )
        , ( ("1.00000", " 0.00000", "[| tan(5*PI/36) |]")
          , ("1.00000", " 0.00000", "[| tan(7*PI/36) |]")
          , ("1.00000", "[| tan(7*PI/36) |]", "[| tan(7*PI/36) |]")
          )
        , 2
        )
      ; ( "test013"
        , ( ("0.0", "0.0", "0.0")
          , ("928.30602933469242543651", "-719.67724526266454176948", "0.0")
          , ("993.66257841287426799681", "-105.78847548707140902024", "0.0")
          )
        , ( ("928.30602933469242543651", "-719.67724526266454176948", "833.742")
          , ("993.66257841287426799681", "-105.78847548707140902024", "0.0")
          , ("993.66257841287426799681", "-105.78847548707140902024", "833.742")
          )
        , 1
        )
      ; ( "test014"
        , ( ("0", "0", "0")
          , ("1", "0", "0")
          , ("1", "0", "1")
          )
        , ( ("0.83526403996", "0.53627252489", "0")
          , ("0.84635429229", "0.47287286519", "0")
          , ("0.86250280593", "0.44760092097", "0")
          )
        , 1
        )
      ; ( "test015"
        , ( ("-1", "0", "0")
          , (" 0", "0", "0")
          , ("-1", "1", "0")
          )
        , ( ("-1", "0", "0")
          , ("-1", "0", "1")
          , ("-1", "1", "1")
          )
        , 1
        )
      ; ( "test016"
        , ( ("0.0871557000", "0.0000000000", "0.9961950000")
          , ("0.2546600000", "0.0462139000", "0.9659260000")
          , ("0.2588190000", "0.0000000000", "0.9659260000")
          )
        , ( ("0.0857551000", "0.0155623000", "0.9961950000")
          , ("0.0871557000", "0.0000000000", "0.9961950000")
          , ("0.2546600000", "0.0462139000", "0.9659260000")
          )
      , 1
        )
      ]

  (* Geom3 part_tris tests *)
  let test_part_tris group (nm, ts, t, expected)=
    let ps =
      G.part_tris
        (List.map intern_tri ts)
        (intern_tri t)
    in
    let actual = List.length ps in
    check_outcome_eq group nm expected actual

  let _ =
    register4 "Geom3.part_tris" test_part_tris
      [ ( "test001"
        , [ ( ("0.0", "0.0", "0.0")
            , ("1.0", "0.0", "1.0")
            , ("1.0", "0.0", "0.0")
            )
          ]
        , ( ("1.0", "1.0", "1.0")
          , ("1.0", "0.0", "[| tan(2*PI/9) |]")
          , ("1.0", "0.0", "1.0")
          )
        , 1
        )
      ; ( "test002"
        , [ ( ("1.0", "1.0", "1.0")
            , ("1.0", "0.0", "[| tan(2*PI/9) |]")
            , ("1.0", "0.0", "1.0")
            )
          ]
        , ( ("0.0", "0.0", "0.0")
          , ("1.0", "0.0", "1.0")
          , ("1.0", "0.0", "0.0")
          )
        , 2
        )
      ; ( "test003"
        , [ ( ("1.0", "0.0", "0.4")
            , ("1.0", "0.0", "1.0")
            , ("1.0", "1.0", "1.0")
            )
          ]
        , ( ("1.0", "0.0", "0.0")
          , ("0.7", "0.0", "0.7")
          , ("1.0", "0.0", "1.0")
          )
        , 2
        )
      ; ( "test004"
        , [ ( ("0.00000", "0.0", " 0.00000")
            , ("[| cos(PI/4) |]", "0.0", "[| -cos(PI/4) |]")
            , ("[| cos(PI/4) |]", "1.0", "[| -cos(PI/4) |]")
            )
          ; ( ("0.00000", "0.0", " 0.00000")
            , ("0.00000", "1.0", " 0.00000")
            , ("[| cos(PI/4) |]", "1.0", "[| -cos(PI/4) |]")
            )
          ; ( ("[| cos(PI/4) |]", "0.0", "[| cos(PI/4) |]")
            , ("[| 2*cos(PI/4) |]", "0.0", "0.00000")
            , ("[| 2*cos(PI/4) |]", "1.0", "0.00000")
            )
          ; ( ("[| cos(PI/4) |]", "0.0", "[| cos(PI/4) |]")
            , ("[| cos(PI/4) |]", "1.0", "[| cos(PI/4) |]")
            , ("[| 2*cos(PI/4) |]", "1.0", "0.00000")
            )
          ; ( ("0.00000", "0.0", " 0.00000")
            , ("[| cos(PI/4) |]", "0.0", "[| -cos(PI/4) |]")
            , ("[| 2*cos(PI/4) |]", "0.0", " 0.00000")
            )
          ; ( ("0.00000", "0.0", "0.00000")
            , ("[| cos(PI/4) |]", "0.0", "[| cos(PI/4) |]")
            , ("[| 2*cos(PI/4) |]", "0.0", "0.00000")
            )
          ; ( ("0.00000", "1.0", " 0.00000")
            , ("[| cos(PI/4) |]", "1.0", "[| -cos(PI/4) |]")
            , ("[| 2*cos(PI/4) |]", "1.0", " 0.00000")
            )
          ; ( ("0.00000", "1.0", "0.00000")
            , ("[| cos(PI/4) |]", "1.0", "[| cos(PI/4) |]")
            , ("[| 2*cos(PI/4) |]", "1.0", "0.00000")
            )
          ; ( ("0.00000", "0.0", "0.00000")
            , ("0.00000", "1.0", "0.00000")
            , ("[| cos(PI/4) |]", "1.0", "[| cos(PI/4) |]")
            )
          ; ( ("0.00000", "0.0", "0.00000")
            , ("[| cos(PI/4) |]", "0.0", "[| cos(PI/4) |]")
            , ("[| cos(PI/4) |]", "1.0", "[| cos(PI/4) |]")
            )
          ; ( ("[| cos(PI/4) |]", "0.0", "[| -cos(PI/4) |]")
            , ("[| cos(PI/4) |]", "1.0", "[| -cos(PI/4) |]")
            , ("[| 2*cos(PI/4) |]", "1.0", " 0.00000")
            )
          ; ( ("[| cos(PI/4) |]", "0.0", "[| -cos(PI/4) |]")
            , ("[| 2*cos(PI/4) |]", "0.0", " 0.00000")
            , ("[| 2*cos(PI/4) |]", "1.0", " 0.00000")
            )
          ]
        , ( ("0.0", "0.0", "0.0")
          , ("1.0", "0.0", "0.0")
          , ("1.0", "0.0", "1.0")
          )
        , 3
        )
      ]

  (* Geom3 isect_pl tests *)
  let test_isect_pl group (nm, p, l, expected) =
    let actual = G.isect_pl (intern_plane p) (intern_line l) in
    let output_to_string = function
      | G.PLOn -> "PLOn"
      | G.PLNone ->  "PLNone"
      | G.PLThru pt -> Printf.sprintf "PLThru %s" (G.string_of_pt pt)
    in
    check_outcome_equiv
      ~output_to_string
      group nm G.equiv_isect_pln
      expected actual

  let _ =
    register4 "Geom3.isect_pl" test_isect_pl
      [ ( "test001"
        , ( ("0.0", "0.0", "0.0")
          , ("1.0", "1.0", "1.0")
          , ("1.0", "0.0", "0.0")
          )
        , ( ("0.0", "0.0", "0.0")
          , ("1.0", "0.0", "0.0")
          )
        , G.PLOn
        )
      ; ( "test002"
        , ( ("0.0", "1.0", "0.0")
          , ("1.0", "1.0", "0.0")
          , ("0.0", "0.0", "0.0")
          )
        , ( ("0.0", "0.0", " 1.0")
          , ("0.0", "0.0", "-1.0")
          )
        , G.PLThru (intern_pt ("0.0", "0.0", "0.0"))
        )
      ; ( "test003"
        , ( (" 0.0", " 1.0", "0.0")
          , ("-1.0", " 0.0", "0.0")
          , (" 1.0", " 0.0", "0.0")
          )
        , ( ("0.0", "0.5", " 1.0")
          , ("0.0", "0.5", "-1.0")
          )
        , G.PLThru (intern_pt ("0.0", "0.5", "0.0"))
        )
      ; ( "test004"
        , ( ("0.0", " 0.0", "0.0")
          , ("[| cos(PI/4) |]", " 0.0", "[| cos(PI/4) |]")
          , ("1.0", " 0.0", "0.0")
          )
        , ( ("[| (1 + cos(PI/4)) / 3 |]", "0.0", "[| cos(PI/4) / 3 |]")
          , ("[| cos(PI/4)*2 + 2 |]", "[| cos(PI/4)*2 + 2 |]", "[| cos(PI/4)*2 + 2 |]")
          )
        , G.PLThru (intern_pt ("[| (1 + cos(PI/4)) / 3 |]", "0.0", "[| cos(PI/4) / 3 |]"))
        )
      ]

  let test_empty_tri group (nm, t, expected) =
    let t = intern_tri t in
    let actual = G.empty_tri t in
    let output_to_string = string_of_bool in
    let describe_input () = G.threejs_of_tri "REINCARNATE" t in
    check_outcome_eq
      ~describe_input
      ~output_to_string
      group nm expected actual

  let _ =
    register3 "Geom3.empty_tri" test_empty_tri
      [ ( "test001"
        , ( ("0", "0.71406", "0.71406")
          , ("0", "0.49858", "1")
          , ("0", "0", "0")
          )
        , false
        )
      ]

end

module Test1D = struct

  module S = S1
  module M = M1
  module C = C1
  module M1Parse = RParse.MakeMesh1Parser(N)(M)
  module C1Parse = RParse.MakeCAD1Parser(N)(M)(C)


  (* 1D compiler tests *)

  let test_compile group (nm, c, m) =
    let cad = C1Parse.of_string c in
    let actual = C.compile cad in
    let expected = M1Parse.of_string m in
    check_outcome_equiv group nm M.equiv expected actual

  let _ =
    register3 "CAD1.compile" test_compile
    [ ( "empty"
      , "Empty"
      , "[]")
    ; ( "unit"
      , "Unit"
      , "[0.0; 1.0]")
    ; ( "trans1"
      , "Trans (1) {
          Unit
         }"
      , "[1.0; 2.0]")
    ; ( "trans5"
      , "Trans (5) {
          Unit
         }"
      , "[5.0; 6.0]")
    ; ( "scale5"
      , "Scale (5) {
          Unit
         }"
      , "[0.0; 5.0]")
    ; ( "test006"
      , "Union {
          Scale (5) {
            Unit
          }
          Trans(-2) {
            Unit
          }
         }"
      , "[-2.0; -1.0; 0.0; 5.0]")
    ; ( "test007"
      , "Hull {
           Union {
             Scale (5) {
               Unit
             }
             Trans (-2) {
               Unit
             }
           }
         }"
      , "[-2.0; 5.0]")
    ; ( "test008"
      , "Diff {
          Scale (5) {
            Unit
          }
          Trans(-2) {
            Unit
          }
         }"
      , "[0.0; 5.0]")
    ; ( "test009"
      , "Inter {
          Scale (5) {
            Unit
          }
          Trans(-2) {
            Unit
          }
         }"
     , "[]")
    ]

  (* 1D simplify tests *)
  let test_simplify group (nm, c, expected) =
    let c'  = C1Parse.of_string c in
    let actual = C.simplify c' in
    let expected = C1Parse.of_string expected in
    check_outcome_equiv group nm M.equiv
    (C.compile actual) (C.compile expected)

  let _ =
    register3 "CAD1.simplify" test_simplify
    [ ( "empty"
      , "Empty"
      , "Empty")
    ; ( "unit"
      , "Unit"
      , "Unit")
    ; ( "trans0"
      , "Trans (0) {
           Unit
         }"
      , "Unit")
    ; ( "trans0scale0"
      , "Trans (0) {
           Scale (1) {
             Unit
           }
         }"
      , "Unit")
    ; ( "scale5"
      , "Scale (5) {
           Unit
         }"
      , "Scale (5) {
           Unit
         }")
    ; ( "test006"
      , "Union {
           Scale (1) {
             Unit
           }
           Trans (0) {
             Unit
           }
         }"
      , "Unit")
    ; ( "test007"
      , "Union {
           Scale (5) {
             Unit
           }
           Trans (-2) {
             Unit
           }
         }"
      , "Union {
           Scale (5) {
             Unit
           }
           Trans (-2) {
             Unit
           }
         }")
    ; ( "test008"
      , "Hull {
           Union {
             Unit
             Scale (5) {
               Unit
             }
           }
         }"
      , "Scale (5) {
           Unit
        }")
    ; ( "test009"
      , "Diff {
           Scale (1) {
             Unit
           }
           Trans (0) {
             Unit
           }
         }"
      , "Empty")
    ; ( "test009"
      , "Inter {
           Scale (5) {
             Unit
           }
           Trans (0) {
             Unit
           }
         }"
      , "Unit")
    ]

end

module Test2D = struct

  module S = S2
  module G = G2
  module M = M2
  module C = C2
  module M2Parse = RParse.MakeMesh2Parser(N)(M)
  module C2Parse = RParse.MakeCAD2Parser(N)(M)(C)

  (* 2D mkpgon test *)
  let test_mkpgon_pass group (nm, pts', expected) =
    let pts =
      pts'
        |> List.map (fun x -> Util.pair_map N.of_string x)
        |> List.map (Util.uncurry G2.mkpt)
    in
    let pg =
      try G2.mkpgon pts with
      | G2.RepeatPt  -> failwith "repeat face"
      | G2.SelfIsect -> failwith "selt isect"
    in
    let actual =
      pg |> G2.string_of_pgon
         |> String.split_on_char '('
         |> List.hd
    in
    check_outcome_eq group nm expected actual

  let _ =
    register3 "Geom2.mkpgon_pass" test_mkpgon_pass
      [ ( "test001"
        , [ ("0.0", "0.0")
          ; ("0.0", "1.0")
          ; ("1.0", "1.0")
          ; ("1.0", "0.0")
          ]
        , "Pgon"
        )
      ]

  (* 2D pgon_area test *)
  let test_area group (nm, pts', expected) =
    let pts =
      pts'
        |> List.map (fun x -> Util.pair_map N.of_string x)
        |> List.map (Util.uncurry G2.mkpt)
    in
    let pg =
      try G2.mkpgon pts with
      | G2.RepeatPt  -> failwith "repeat face"
      | G2.SelfIsect -> failwith "selt isect"
    in
    let actual = G2.area pg in
    check_outcome_equiv group nm N.equiv expected actual

  let _ =
    register3 "Geom2.area" test_area
      [ ( "test001"
        , [ ("0.0", "0.0")
          ; ("0.0", "1.0")
          ; ("1.0", "1.0")
          ; ("1.0", "0.0")
          ]
        , N.n1
        )
      ]

  (* 2D part_dseg *)
  let test_part_dseg group (nm, s1', s2', expected) =
    let s1 =
      s1' |> Util.pair_map (Util.pair_map num_of_string)
          |> Util.pair_map (Util.uncurry  G.mkpt)
          |> Util.uncurry  G.mkdseg
    in
    let s2 =
      s2' |> Util.pair_map (Util.pair_map num_of_string)
          |> Util.pair_map (Util.uncurry  G.mkpt)
          |> Util.uncurry  G.mkdseg
    in
    let ps = G.part_dseg s1 s2 in
    let actual = List.length ps in
    check_outcome_eq group nm expected actual

  let _ =
    register4 "Geom2.part_dseg" test_part_dseg
      [ ( "test001"
        , ( ("0.0", "1.0")
          , ("1.0", "1.0")
          )
        , ( ("0.3", "0.5")
          , ("0.4", "1.0")
          )
        , 1
        )
      ; ( "test002"
        , ( ("0.0", "0.0")
          , ("1.0", "1.0")
          )
        , ( ("0.5", "0.2")
          , ("0.5", "0.5")
          )
        , 1
        )
      ; ( "test003"
        , ( ("0.3", "0.5")
          , ("0.4", "1.0")
          )
        , ( ("0.0", "1.0")
          , ("1.0", "1.0")
          )
        , 2
        )
      ]

  (* 2D mesh area *)
  let test_area group (nm, m', expected) =
    let m = M2Parse.of_string m' in
    let area = M2.area m in
    check_outcome_equiv
      group nm N.equiv (N.of_string expected) area

  let _ =
    register3 "Mesh2.area" test_area
      [ ( "test001"
        , "[ ((0.0, 0.0), (1.0, 0.0))
           ; ((1.0, 0.0), (1.0, 1.0))
           ; ((1.0, 1.0), (0.0, 1.0))
           ; ((0.0, 1.0), (0.0, 0.0))
           ]"
        , "1"
        )
      ]

  (* 2D cycle extraction *)
  let test_cycle group (nm, m, expected) =
    let m = M2Parse.of_string m in
    let cs = M.cycles m in
    let actual = List.length cs in
    check_outcome_eq group nm expected actual

  let _ =
    register3 "Mesh2.cycles" test_cycle
         [ ( "test001"
        , "[ ((0.0, 0.0), (1.0, 0.0))
           ; ((1.0, 0.0), (1.0, 1.0))
           ; ((1.0, 1.0), (0.0, 1.0))
           ; ((0.0, 1.0), (0.0, 0.0))
           ; ((0.2, 0.2), (0.4, 0.2))
           ; ((0.4, 0.2), (0.4, 0.4))
           ; ((0.4, 0.4), (0.2, 0.4))
           ; ((0.2, 0.4), (0.2, 0.2))
           ]"
        , 2
        )
      ; ( "test002"
        , "[ ((0.0, 0.0), (1.0, 0.0))
           ; ((1.0, 0.0), (1.0, 1.0))
           ; ((1.0, 1.0), (0.0, 1.0))
           ; ((0.0, 1.0), (0.0, 0.0))
           ; ((0.2, 0.2), (0.4, 0.2))
           ; ((0.4, 0.2), (0.4, 0.4))
           ; ((0.4, 0.4), (0.2, 0.4))
           ; ((0.2, 0.4), (0.2, 0.2))
           ; ((0.8, 0.8), (0.9, 0.8))
           ; ((0.9, 0.8), (0.9, 0.9))
           ; ((0.9, 0.9), (0.8, 0.9))
           ; ((0.8, 0.9), (0.8, 0.8))
           ]"
        , 3
        )
      ; ( "test003"
        , "[ ((0.0, 0.0), (1.0, 0.0))
           ; ((1.0, 0.0), (1.0, 1.0))
           ; ((1.0, 1.0), (0.0, 1.0))
           ; ((0.0, 1.0), (0.0, 0.0))
           ; ((1.0, 1.0), (1.0, 3.0))
           ; ((1.0, 3.0), (3.0, 3.0))
           ; ((3.0, 3.0), (3.0, 1.0))
           ; ((3.0, 1.0), (1.0, 1.0))
           ; ((0.2, 0.2), (0.4, 0.2))
           ; ((0.4, 0.2), (0.4, 0.4))
           ; ((0.4, 0.4), (0.2, 0.4))
           ; ((0.2, 0.4), (0.2, 0.2))
           ]"
        , 3
        )
      ; ( "test004"
        , "[ ((0.0, 0.0), (1.0, 0.0))
           ; ((1.0, 0.0), (1.0, 1.0))
           ; ((1.0, 1.0), (0.0, 1.0))
           ; ((0.0, 1.0), (0.0, 0.0))
           ; ((0.2, 0.2), (0.5, 0.7))
           ; ((0.5, 0.7), (0.0, 1.0))
           ; ((0.0, 1.0), (0.2, 0.2))
           ]"
        , 2
        )
      ; ( "test005"
        , "[ ((0.0, 0.0), (1.0, 0.0))
           ; ((1.0, 0.0), (1.0, 1.0))
           ; ((1.0, 1.0), (0.0, 1.0))
           ; ((0.0, 1.0), (0.0, 0.0))
           ; ((0.4, 0.9), (0.3, 0.5))
           ; ((0.3, 0.5), (0.7, 0.7))
           ; ((0.7, 0.7), (0.4, 0.9))
           ; ((0.7, 0.7), (0.6, 0.4))
           ; ((0.6, 0.4), (0.8, 0.7))
           ; ((0.8, 0.7), (0.7, 0.7))
           ]"
        , 3
        )
      ; ( "test006"
        , "[ ((0.0, 0.0), (2.0, 0.0))
           ; ((2.0, 0.0), (2.0, 5.0))
           ; ((2.0, 5.0), (0.0, 5.0))
           ; ((0.0, 5.0), (0.0, 0.0))
           ; ((0.0, 5.0), (0.5, 2.5))
           ; ((0.5, 2.5), (1.0, 3.5))
           ; ((1.0, 3.5), (0.0, 5.0))
           ; ((0.0, 0.0), (1.0, 1.5))
           ; ((1.0, 1.5), (0.5, 2.5))
           ; ((0.5, 2.5), (0.0, 0.0))
           ; ((2.0, 0.0), (1.0, 1.5))
           ; ((1.0, 1.5), (1.5, 2.5))
           ; ((1.5, 2.5), (2.0, 0.0))
           ; ((2.0, 5.0), (1.5, 2.5))
           ; ((1.5, 2.5), (1.0, 2.5))
           ; ((1.0, 2.5), (2.0, 5.0))
           ]"
        , 5
        )
      ; ( "test007"
        , "[ ((0.0, 0.0), (1.0, 0.0))
           ; ((1.0, 0.0), (1.0, 1.0))
           ; ((1.0, 1.0), (0.0, 1.0))
           ; ((0.0, 1.0), (0.0, 0.0))
           ]"
        , 1
        )
      ; ( "test008"
        , "[ ((0.4, 1.0), (0.3, 0.5))
           ; ((0.3, 0.5), (0.7, 0.7))
           ; ((0.7, 0.7), (0.4, 1.0))
           ; ((0.7, 0.7), (0.6, 0.4))
           ; ((0.6, 0.4), (0.8, 0.7))
           ; ((0.8, 0.7), (0.7, 0.7))
           ]"
        , 2
        )
      ; ( "test009"
        , "[ ((0.0, 0.0), (1.0, 0.0))
           ; ((1.0, 0.0), (1.0, 1.0))
           ; ((1.0, 1.0), (0.0, 1.0))
           ; ((0.0, 1.0), (0.0, 0.0))
           ]"
        , 1
        )
      ]

  (* 2D mesh union tests *)
  let test_mesh_union group (nm, a, b, expected) =
    let mA = M2Parse.of_string a in
    let mB = M2Parse.of_string b in
    let expected = M2Parse.of_string expected in
    let actual = M.union mA mB in
    check_outcome_equiv group nm M.equiv expected actual

  let _ =
    register4 "Mesh2.union" test_mesh_union
    [
    ]

  (* 2D compiler tests *)
  let test_compile group (nm, c, m) =
    let cad = C2Parse.of_string c in
    let actual = C.compile cad in
    let expected = M2Parse.of_string m in
    check_outcome_equiv group nm M.equiv expected actual

  let _ =
    register3 "CAD2.compile" test_compile
    [ ( "empty"
      , "Empty"
      , "[]")
    ; ( "unit"
      , "Unit"
      , "[ ((0.0, 0.0), (1.0, 0.0))
         ; ((1.0, 0.0), (1.0, 1.0))
         ; ((1.0, 1.0), (0.0, 1.0))
         ; ((0.0, 1.0), (0.0, 0.0))
         ]")
    ; ( "test003"
      , "Trans (3, 5) {
           Unit
         }"
      , "[ ((3.0, 5.0), (4.0, 5.0))
         ; ((3.0, 6.0), (3.0, 5.0))
         ; ((4.0, 5.0), (4.0, 6.0))
         ; ((4.0, 6.0), (3.0, 6.0))
         ]")

    ; ( "test004"
      , "Scale (2, 3) {
           Unit
         }"
      , "[ ((0.0, 0.0), (2.0, 0.0))
         ; ((0.0, 3.0), (0.0, 0.0))
         ; ((2.0, 0.0), (2.0, 3.0))
         ; ((2.0, 3.0), (0.0, 3.0))
         ]")
    ; ( "test005"
      , "Rotate (30) {
           Unit
         }"

      , "[ ((-0.5000000000, [| cos(PI/6) |]), (0.0000000000, 0.0000000000))
         ; ((-0.5000000000, [| cos(PI/6) |]), ([| cos(PI/6) - 0.5 |], [| 0.5 + cos(PI/6) |]))
         ; (( [| cos(PI/6) - 0.5 |], [| 0.5 + cos(PI/6) |]), ([| cos(PI/6) |], 0.5000000000))
         ; (( 0.0000000000, 0.0000000000), ([| cos(PI/6) |], 0.5000000000))
         ]")
    ; ( "test006"
      , "Union {
           Unit
           Unit
         }"
      , "[ ((0.0, 0.0), (1.0, 0.0))
         ; ((1.0, 0.0), (1.0, 1.0))
         ; ((1.0, 1.0), (0.0, 1.0))
         ; ((0.0, 1.0), (0.0, 0.0))
         ]")
    ; ( "test007"
      , "Diff {
           Unit
           Unit
         }"
      , "[]")
    ; ( "test008"
      , "Diff {
           Union {
              Unit
              Trans (0, 2) {
                Unit
              }
           }
           Trans (0, -1.5) {
             Scale (1, 3) {
                Unit
             }
           }
         }"
      , "[ ((0.0, 2.0), (0.0, 3.0))
         ; ((0.0, 2.0), (1.0, 2.0))
         ; ((0.0, 3.0), (1.0, 3.0))
         ; ((1.0, 2.0), (1.0, 3.0))
         ]")
    ]

  (* 2D simplify tests *)
  let test_simplify group (nm, c, expected) =
    let c'  = C2Parse.of_string c in
    let actual = C.simplify c' in
    let expected = C2Parse.of_string expected in
    check_outcome_equiv
      group nm M.equiv
      (C.compile expected)
      (C.compile actual)

  let _ =
    register3 "CAD2.simplify" test_simplify
    [ ( "empty"
      , "Empty"
      , "Empty")
    ; ( "unit"
      , "Unit"
      , "Unit")
    ; ( "test003"
      , "Trans (0, 0) {
           Unit
         }"
      , "Unit")
    ; ( "test004"
      , "Scale (5, 3) {
           Unit
         }"
      , "Scale (5, 3) {
           Unit
         }")
    ; ( "test005"
      , "Trans (0, 0) {
           Scale(1, 1) {
             Unit
           }
         }"
      , "Unit")
    ; ( "test006"
      , "Union {
           Scale (1, 1) {
             Unit
           }
           Trans (0, 0) {
             Unit
           }
         }"
      , "Unit")
    ; ( "test007"
      , "Union {
           Scale (5, 2) {
             Unit
           }
           Trans (-2, -1) {
             Unit
           }
         }"
      , "Union {
           Scale (5, 2) {
             Unit
           }
           Trans (-2, -1) {
             Unit
           }
         }")
    ; ( "test008"
      , "Hull {
           Union {
              Scale (5, 7) {
                Unit
              }
              Unit
           }
         }"
      , "Scale (5, 7) {
           Unit
         }")
    ; ( "test009"
      , "Diff {
           Scale (1, 1) {
             Unit
           }
           Trans (0, 0) {
             Unit
           }
         }"
      , "Empty")
    ; ( "test009"
      , "Inter {
           Scale (5, 9) {
             Unit
           }
           Trans (0, 0) {
             Unit
           }
         }"
      , "Unit")
    ]

end

let _ = Printexc.record_backtrace true

let usage = "
Test

OPTIONS:

  --eps-abs E            set absolute epsilon equivalence near zero
  --eps-rel E            set relative epsilon equivalence away from zero
  --epsilon E            set absolute and relative epsilons to E
  --from-file <file>     run tests listed in given file (one per line)
  --timeout T            timeout before test considered a failure
  -h --help              print this usage information and exit
  --list-groups          list all test-group names
  --list-tests <group>   list all test names in given group
  --log-failures <file>  write list of failing tests to given file
  --test '<regex>'       regular expression to determine which tests to run
  --verbose              print more detail about failing tests
"

let pred : (string -> bool) ref = ref (fun _ -> true)
let log_failures : string option ref = ref None

let parse_args () =
  let bogus_arg x =
    prerr_endline usage;
    failwith ("Test: bogus arg: " ^ x)
  in
  let rec loop = function
    | [] -> ()
    | "--eps-abs" :: e :: rest ->
        begin try
          let e = N.of_string e in
          N.set_eps_abs e;
        with _ ->
          bogus_arg ("--eps-abs " ^ e)
        end;
        loop rest
    | "--eps-rel" :: e :: rest ->
        begin try
          let e = N.of_string e in
          N.set_eps_rel e;
        with _ ->
          bogus_arg ("--eps-rel " ^ e)
        end;
        loop rest
    | "--epsilon" :: e :: rest ->
        begin try
          let e = N.of_string e in
          N.set_eps_abs e;
          N.set_eps_rel e;
        with _ ->
          bogus_arg ("--epsilon " ^ e)
        end;
        loop rest
    | "--oprec" :: p :: rest ->
        begin try
          let p = int_of_string p in
          N.set_oprec p;
        with _ ->
          bogus_arg ("--oprec " ^ p)
        end;
        loop rest
    | "--from-file" :: file :: rest ->
       let lines =
         file |> of_file_lines
              |> List.map String.trim
       in
       let old = !pred in
       pred := (fun x -> old x && List.mem x lines);
       loop rest
    | "--timeout" :: t :: rest ->
        begin try
          _timeout := int_of_string t;
        with _ ->
          bogus_arg ("--timeout " ^ t)
        end;
        loop rest
    | "-h" :: rest
    | "--help" :: rest ->
        print_endline usage;
        Pervasives.exit 0
    | "--list-groups" :: rest ->
       !tests |> List.rev
              |> List.iter (fun (Test (nm, _, _)) -> print_endline nm);
        Pervasives.exit 0
    | "--list-tests" :: group :: rest ->
       let show_tests group ts =
         List.iter (fun (nm, _) -> print_endline (group ^ "." ^ nm)) ts
       in let show_group (Test (nm, _, ts)) =
         if nm = group then show_tests nm ts else ()
       in
       !tests |> List.rev
              |> List.iter show_group;
        Pervasives.exit 0
    | "--log-failures" :: file :: rest ->
       log_failures := Some file;
       loop rest
    | "--test" :: f :: rest ->
       let old = !pred in
       pred := (fun s -> old s && Str.string_match (Str.regexp f) s 0);
       loop rest
    | "--verbose" :: rest ->
       verbose := true;
       loop rest
    | "--noinvariants" :: rest ->
        M3.set_invariants false;
        loop rest
    | x :: _ ->
        bogus_arg x
  in
  Sys.argv
    |> Array.to_list
    |> List.tl
    |> loop


(* run tests *)
let () =
  Printexc.record_backtrace true;
  parse_args ();
  let tick = Unix.gettimeofday () in
  !tests
    |> List.rev
    |> List.iter (run_test !pred);
  let tock = Unix.gettimeofday () in
  Printf.printf "Pass: %d\n" (List.length !passed);
  Printf.printf "Fail: %d\n" (List.length !failed);
  if !failed <> [] then begin
    let oc =
      match !log_failures with
      | None ->
          stdout
      | Some f ->
          Printf.printf "Logging failures to %s\n" f;
          Pervasives.open_out f
    in
    !failed
      |> List.rev
      |> List.iter (Printf.fprintf oc "  %s\n")
  end;
  Printf.printf "Time: %.3f\n" (tock -. tick)
